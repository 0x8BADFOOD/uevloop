<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>µEvLoop: µEvLoop</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">µEvLoop
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">A fast and lightweight event loop aimed at embedded platforms in C99.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">µEvLoop </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A fast and lightweight event loop aimed at embedded platforms in C99.</p>
<h2>About</h2>
<p>µEvLoop is a microframework build around a lightweight event loop. It provides the programmer the building blocks to put together async, interrupt-based systems.</p>
<p>µEvLoop is loosely inspired on the Javascript event loop and aims to provide a similar programming model. Many similar concepts, such as events and closures are included. It is aimed at environments with very restricted resources, but can be run on all kinds of platforms.</p>
<h3>*DISCLAIMER*</h3>
<p>µEvLoop is in its early days and the API may change at any moment for now. Although it's well tested, use it with caution. Anyway, feedback is most welcome.</p>
<h2>Highlights</h2>
<ul>
<li>As minimalist and loose-coupled as possible.</li>
<li>Does not allocate any dynamic memory on its own. All static memory needed is either allocated explicitly by the user or implicitly by <a href="#containers">containers</a>.</li>
<li>Small memory footprint and runtime latency.</li>
<li>Does not try to make assumptions about the underlying system.</li>
<li>Depends only on a very small subset of the standard libc, mostly for fixed size integers and booleans.</li>
</ul>
<h2>API documentation</h2>
<p>The API documentation is automatically generated by Doxygen. Find it <a href="https://andsmedeiros.github.io/uevloop/">here</a>.</p>
<h2>Testing</h2>
<p>Tests are written using a simple set of macros. To run them, execute <code>make test</code>.</p>
<p>Please note that the makefile shippped is meant to be run in modern Linux systems. Right now, it makes use of bash commands and utilities as well as expects libSegFault.so to be in a hardcoded path.</p>
<p>If this doesn't fit your needs, edit it as necessary.</p>
<h3>Test coverage</h3>
<p>To generate code coverage reports, run <code>make coverage</code>. This requires <code>gcov</code>, <code>lcov</code> and <code>genhtml</code> to be on your <code>PATH</code>. After running, the results can be found on <code>uevloop/coverage/index.html</code>.</p>
<h2>Core data structures</h2>
<p>These data structures are used across the whole framework. They can also be used by the programmer in userspace as required.</p>
<p>Core data structures can be found on the <code>src/utils</code> directory.</p>
<p><b>All core data structures are unsafe. Be sure to wrap access to them in <a href="#critical-sections">critical sections</a> if you mean to share them amongst contexts asynchronous to each other.</b></p>
<h3>Closures</h3>
<p>A closure is an object that binds a function to some context. When invoked with arbitrary parameters, the bound function is called with both context and parameters available. With closures, some very powerful programming patterns, as functional composition, becomes way easier to implement.</p>
<p>As closures are somewhat light, it is often useful to pass them around by value.</p>
<h4>Basic closure usage</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="closure_8h.html">utils/closure.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *add(closure_t *<a class="code" href="structclosure.html">closure</a>){</div><div class="line">  uintptr_t value1 = (uintptr_t)closure-&gt;context;</div><div class="line">  uintptr_t value2 = (uintptr_t)closure-&gt;params;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(value1 + value2);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// Binds the function `add` to the context (5)</span></div><div class="line">closure_t add_five = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;add, (<span class="keywordtype">void</span> *)5, NULL);</div><div class="line"></div><div class="line"><span class="comment">// Invokes the closure with the parameters set to (2)</span></div><div class="line">uintptr_t result = (uintptr_t)<a class="code" href="closure_8h.html#abc4ac87add333788e108d2dcdad4104d">closure_invoke</a>(&amp;add_five, (<span class="keywordtype">void</span> *)2);</div><div class="line"><span class="comment">// Result is 7</span></div></div><!-- fragment --><h4>*A word on (void *)*</h4>
<p>Closures take the context and parameters as a void pointer and return the same. This is meant to make possible to pass and return complex objects from them.</p>
<p>At many times, however, the programmer may find the values passed/returned are small and simple (<em>i.e.</em>: smaller than a pointer). If so, it is absolutely valid to cast from/to a <code>uintptr_t</code> or other data type known to be at most the size of a pointer. The above example does that to avoid creating unnecessary object pools or allocating dynamic memory.</p>
<h3>Circular queues</h3>
<p>Circular queues are fast FIFO (<em>first-in-first-out</em>) structures that rely on a pair of indices to maintain state. As the indices are moved forward on push/pop operations, the data itself is not moved at all.</p>
<p>The size of µEvLoop's circular queues are <b>required</b> to be powers of two, so it is possible to use fast modulo-2 arithmetic. As such, on queue creation, the size <b>must</b> be provided in its log2 form.</p>
<p><em><b>FORGETTING TO SUPPLY THE QUEUE'S SIZE IN LOG2 FORM MAY CAUSE THE STATIC ALLOCATION OF GIANT MEMORY POOLS</b></em></p>
<h4>Basic circular queue usage</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="circular-queue_8h.html">utils/circular-queue.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define BUFFER_SIZE_LOG2N   (5)</span></div><div class="line"><span class="preprocessor">#define BUFFER_SIZE         (1&lt;&lt;BUFFER_SIZE_LOG2N)  // 1&lt;&lt;5 == 2**5 == 32</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">cqueue_t queue;</div><div class="line"><span class="keywordtype">void</span> *buffer[BUFFER_SIZE];</div><div class="line"><span class="comment">// Created a queue with 32 (2**5) slots</span></div><div class="line"><a class="code" href="circular-queue_8h.html#a39b3eee4b6d829de97f24b32e577f84c">cqueue_init</a>(&amp;queue, buffer, BUFFER_SIZE_LOG2N);</div><div class="line"></div><div class="line"><span class="comment">// Push items in the queue</span></div><div class="line"><a class="code" href="circular-queue_8h.html#a2113f1bc7990d617f720e7b3f8fe6d31">cqueue_push</a>(&amp;queue, (<span class="keywordtype">void</span> *)3);</div><div class="line"><a class="code" href="circular-queue_8h.html#a2113f1bc7990d617f720e7b3f8fe6d31">cqueue_push</a>(&amp;queue, (<span class="keywordtype">void</span> *)2);</div><div class="line"><a class="code" href="circular-queue_8h.html#a2113f1bc7990d617f720e7b3f8fe6d31">cqueue_push</a>(&amp;queue, (<span class="keywordtype">void</span> *)1);</div><div class="line"></div><div class="line"><span class="comment">// Pop items from the queue</span></div><div class="line">uintptr_t value1 = (uintptr_t)<a class="code" href="circular-queue_8h.html#a1684e7b47c00fab34aa17adf2d7ce996">cqueue_pop</a>(&amp;queue); <span class="comment">// value1 is 3</span></div><div class="line">uintptr_t value2 = (uintptr_t)<a class="code" href="circular-queue_8h.html#a1684e7b47c00fab34aa17adf2d7ce996">cqueue_pop</a>(&amp;queue); <span class="comment">// value2 is 2</span></div><div class="line">uintptr_t value3 = (uintptr_t)<a class="code" href="circular-queue_8h.html#a1684e7b47c00fab34aa17adf2d7ce996">cqueue_pop</a>(&amp;queue); <span class="comment">// value3 is 1</span></div></div><!-- fragment --><p>Circular queues store void pointers. As it is the case with closures, this make possible to store complex objects within the queue, but often typecasting to an smaller value type is more useful.</p>
<h3>Object pools</h3>
<p>On embedded systems, hardware resources such as processing power or RAM memory are often very limited. As a consequence, dynamic memory management can become very expensive in both aspects.</p>
<p>Object pools are statically allocated arrays of objects whose addresses are stored in a queue. Whenever the programmer needs a object in runtime, instead of dynamically allocating memory, it is possible to simply pop an object pointer from the pool and use it away.</p>
<p>Because object pools are statically allocated and backed by <a href="#circular-queues">circular queues</a>, they are very manageable and fast to operate.</p>
<h4>Basic object pool usage</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="object-pool_8h.html">utils/object-pool.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>obj obj_t;</div><div class="line"><span class="keyword">struct </span>obj {</div><div class="line">  uint32_t num;</div><div class="line">  <span class="keywordtype">char</span> str[32];</div><div class="line">  <span class="comment">// Whatever</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// The log2 of our pool size.</span></div><div class="line"><span class="preprocessor">#define POOL_SIZE_LOG2N   (5)</span></div><div class="line"><a class="code" href="object-pool_8h.html#a3bbfb93498117268841be6917a5aebad">DECLARE_OBJPOOL_BUFFERS</a>(obj_t, POOL_SIZE_LOG2N, my_pool);</div><div class="line"></div><div class="line">objpool_t my_pool;</div><div class="line"><a class="code" href="object-pool_8h.html#a8721d8a9e8bd92172ce8986a7f40a3f8">objpool_init</a>(&amp;my_pool, POOL_SIZE_LOG2N, <span class="keyword">sizeof</span>(obj_t), <a class="code" href="object-pool_8h.html#a1f789de8fa7a0b224acaf8f138500cfc">OBJPOOL_BUFFERS</a>(my_pool));</div><div class="line"><span class="comment">// my_pool now is a pool with 32 (2**5) obj_t</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// Whenever the programmer needs a fresh obj_t</span></div><div class="line">obj_t *obj = (obj_t *)<a class="code" href="object-pool_8h.html#a04f039b8b1d56b0c777bff90842993a1">objpool_acquire</a>(&amp;my_pool);</div><div class="line"></div><div class="line"><span class="comment">// When it is no longer needed, return it to the pool</span></div><div class="line"><a class="code" href="object-pool_8h.html#a696ee43102f408a0302e7aa88dd5b757">objpool_release</a>(&amp;my_pool, obj);</div></div><!-- fragment --><h3>Linked lists</h3>
<p>µEvLoop ships a simple linked list implementation thar holds void pointers, as usual.</p>
<h4>Basic linked list usage</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="linked-list_8h.html">utils/linked-list.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">llist_t list;</div><div class="line"><a class="code" href="linked-list_8h.html#aec14da36547cc8d0fd943cd04fca6f2d">llist_init</a>(&amp;list);</div><div class="line"></div><div class="line">llist_node_t nodes[2] = {</div><div class="line">  {(<span class="keywordtype">void</span> *)1, NULL},</div><div class="line">  {(<span class="keywordtype">void</span> *)2, NULL}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Push items into the list</span></div><div class="line"><a class="code" href="linked-list_8h.html#a11fab82b02435333d843a69ee1c76e5b">llist_push_head</a>(&amp;list, &amp;nodes[0]);</div><div class="line"><a class="code" href="linked-list_8h.html#a11fab82b02435333d843a69ee1c76e5b">llist_push_head</a>(&amp;list, &amp;nodes[1]);</div><div class="line"></div><div class="line"><span class="comment">// List now is TAIL-&gt; [1]-&gt; [2]-&gt; NULL. HEAD-&gt; [2]</span></div><div class="line">llist_node_t *node1 = (llist_node_t *)<a class="code" href="linked-list_8h.html#a98e453a407ee90e4342fc62bd4fddf53">llist_pop_tail</a>(&amp;list);</div><div class="line">llist_node_t *node2 = (llist_node_t *)<a class="code" href="linked-list_8h.html#a98e453a407ee90e4342fc62bd4fddf53">llist_pop_tail</a>(&amp;list);</div><div class="line"></div><div class="line"><span class="comment">//node1 == nodes[0] and node2 == nodes[1]</span></div></div><!-- fragment --><h2>Containers</h2>
<p>Containers are objects that encapsulate declaration, initialisation and manipulation of core data structures used by the framework.</p>
<p>They also encapsulates manipulation of these data structures inside <a href="#critical-sections">critical sections</a>, ensuring safe access to shared resources across the system.</p>
<h3>System pools</h3>
<p>The <code>syspools</code> module is a container for the system internal object pools. It contains pools for events and linked list nodes used by the core modules.</p>
<p>The system pools module is meant to be internally operated only. The only responsibility of the programmer is to allocate, initialise and provide it to other core modules.</p>
<p>To configure the size of each pool created, edit <code><a class="el" href="config_8h.html" title="Central repository of system configuration. This is meant to be edited by the programmer as needed...">src/config.h</a></code>.</p>
<h4>System pools usage</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-pools_8h.html">system/containers/system-pools.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">syspools_t pools;</div><div class="line"><a class="code" href="system-pools_8h.html#a5b00c216720de7afc3a3c30a2df60cc4">syspools_init</a>(&amp;pools);</div><div class="line"><span class="comment">// This allocates two pools:</span></div><div class="line"><span class="comment">//   1) pools.event_pool</span></div><div class="line"><span class="comment">//   2) pools.llist_node_pool</span></div></div><!-- fragment --><h3>System queues</h3>
<p>The <code>sysqueues</code> module contains the necessary queues for sharing data amongst the core modules. It holds queues for events in differing statuses.</p>
<p>As is the case with system pools, the <code>sysqueues</code> module should not be directly operated by the programmer, except for declaration and initialisation.</p>
<p>Configure the size of each queue created in <code><a class="el" href="config_8h.html" title="Central repository of system configuration. This is meant to be edited by the programmer as needed...">src/config.h</a></code>.</p>
<h4>System queues usage</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-queues_8h.html">system/containers/system-queues.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">sysqueues_t queues;</div><div class="line"><a class="code" href="system-queues_8h.html#abed67e4f7c2c8dec08899920bcf31a6a">sysqueues_init</a>(&amp;queues);</div><div class="line"><span class="comment">// This allocates two queues:</span></div><div class="line"><span class="comment">//   1) queues.event_queue (events ready to be processed are put here)</span></div><div class="line"><span class="comment">//   2) queues.schedule_queue (events ready to be scheduled are put here)</span></div></div><!-- fragment --><h3>Application</h3>
<p>The <code>application</code> module is a convenient toplevel container for all the internals of an µEvLoop'd app. It is not necessary at all but contains much of the boilerplate in a typical application.</p>
<p>It also proxies functions to the <a href="#event-loop"><code>event loop</code></a> and <a href="#scheduler"><code>scheduler</code></a> modules, serving as a single point entry for the system operation.</p>
<p>The following code is a realistic minimal setup of the framework. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="application_8h.html">system/containers/application.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t counter = 0;</div><div class="line"><span class="keyword">static</span> application_t my_app;</div><div class="line"></div><div class="line"><span class="comment">// 1 kHz timer</span></div><div class="line"><span class="keywordtype">void</span> my_timer_isr(){</div><div class="line">  my_timer_isr_flag = 0;</div><div class="line">  <a class="code" href="application_8h.html#a09474113c2e66d6bc83127dd304125f0">app_update_timer</a>(&amp;my_app, ++counter);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]){</div><div class="line">  <a class="code" href="application_8h.html#a4e7aa187e2612f28e8483a797ec0d951">app_init</a>(&amp;my_app);</div><div class="line"></div><div class="line">  <span class="comment">// Start scheduling timers through my_app.scheduler or enqueuing</span></div><div class="line">  <span class="comment">// closures through my_app.event_loop</span></div><div class="line">  <span class="comment">// Create modules that emit signals and listen to then from here</span></div><div class="line"></div><div class="line">  <span class="keywordflow">while</span>(1){  </div><div class="line">    <a class="code" href="application_8h.html#a0c0f375ef58d963c19482d292363044c">app_tick</a>(&amp;my_app);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>Core modules</h2>
<h3>Scheduler</h3>
<p>The scheduler is a module that keeps track of current execution time and closures to be run in the future. It provides similar functionality to the <code>setTimeout</code> and <code>setInterval</code> Javascript functions.</p>
<p>Two queues lead in and out of it: the inbound schedule_queue is externally fed events that should be scheduled and then accounted for; the outbound event_queue hold events that are due to be collected and processed.</p>
<p>This module needs access to system's pools and queues.</p>
<h4>Basic scheduler initialisation</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-pools_8h.html">system/containers/system-pools.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-queues_8h.html">system/containers/system-queues.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="scheduler_8h.html">system/scheduler.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// Create the system containers</span></div><div class="line">syspools_t pools;</div><div class="line"><a class="code" href="system-pools_8h.html#a5b00c216720de7afc3a3c30a2df60cc4">syspools_init</a>(&amp;pools);</div><div class="line">sysqueues_t queues;</div><div class="line"><a class="code" href="system-queues_8h.html#abed67e4f7c2c8dec08899920bcf31a6a">sysqueues_init</a>(&amp;queues);</div><div class="line"></div><div class="line"><span class="comment">// Create the scheduler</span></div><div class="line">scheduler_t <a class="code" href="structscheduler.html">scheduler</a>;</div><div class="line"><a class="code" href="scheduler_8h.html#ac71114eccc00dabe5874fd70f1b0d78e">sch_init</a>(&amp;scheduler, &amp;pools, &amp;queues);</div></div><!-- fragment --><h4>Scheduler operation</h4>
<p>The <code>scheduler</code> module accepts input of closures and scheduling info an then turns it into a timer event. This timer is then inserted in a timer list, which is sorted by each timer's due time.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="closure_8h.html">utils/closure.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *print_num(closure_t *closure){</div><div class="line">  uintptr_t num = (uintptr_t)closure-&gt;context;</div><div class="line">  printf(<span class="stringliteral">&quot;%d\n&quot;</span>, num);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">closure_t  print_one = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;print_num, (<span class="keywordtype">void</span> *)1, NULL);</div><div class="line">closure_t  print_two = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;print_num, (<span class="keywordtype">void</span> *)2, NULL);</div><div class="line">closure_t  print_three = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;print_num, (<span class="keywordtype">void</span> *)3, NULL);</div><div class="line"></div><div class="line"><span class="comment">// Schedules to run 1000ms in the future.</span></div><div class="line"><a class="code" href="scheduler_8h.html#af81e4cc41f273ded2745a9040ca2e056">sch_run_later</a>(&amp;scheduler, 1000, print_one);</div><div class="line"></div><div class="line"><span class="comment">// Schedules to run at intervals of 500ms, runs the first time after 500ms</span></div><div class="line"><a class="code" href="scheduler_8h.html#a43e2339c242a52f788d74f30ce103ed4">sch_run_at_intervals</a>(&amp;scheduler, 500, <span class="keyword">false</span>, print_two);</div><div class="line"></div><div class="line"><span class="comment">// Schedules to run at intervals of 300ms, runs the first time the next runloop</span></div><div class="line"><a class="code" href="scheduler_8h.html#a43e2339c242a52f788d74f30ce103ed4">sch_run_at_intervals</a>(&amp;scheduler, 300, <span class="keyword">true</span>, print_three);</div></div><!-- fragment --><p>The <code>scheduler</code> must be fed regularly to work. It needs both an update on the running time as an stimulus to process enqueued timers. Ideally, a hardware timer will be consistently incrementing a counter and feeding it at an ISR while in the main loop the scheduler is oriented to process its queue.</p>
<div class="fragment"><div class="line"><span class="comment">// millisecond counter</span></div><div class="line"><span class="keyword">volatile</span> uint32_t counter = 0;</div><div class="line"></div><div class="line"><span class="comment">// 1kHz timer ISR</span></div><div class="line"><span class="keywordtype">void</span> my_timer_isr(){</div><div class="line">  my_timer_isr_flag = 0;</div><div class="line">  <a class="code" href="scheduler_8h.html#a8869b94849a2ee9cb587aaade4a5c4d5">sch_update_timer</a>(&amp;scheduler, ++counter);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// On the main loop</span></div><div class="line"><a class="code" href="scheduler_8h.html#a561a4b7cdcb445d42994da0eb9c160a3">sch_manage_timers</a>(&amp;scheduler);</div></div><!-- fragment --><p>When the function <code>sch_manage_timers</code> is called, two things happen:</p><ol type="1">
<li>The <code>schedule_queue</code> is flushed and every timer in it is scheduled accordingly;</li>
<li>The scheduler iterates over the scheduled timer list from the beginning and breaks it when it finds a timer scheduled further in the future. It then proceeds to move each timer from the extracted list to the <code>event_queue</code>, where they will be further collected and processed.</li>
</ol>
<h4>Scheduler time resolution</h4>
<p>There are two distinct factors that will determine the actual time resolution of the scheduler:</p><ol type="1">
<li>the frequency of the feed in timer ISR</li>
<li>the frequency the function <code>sch_manage_timers</code> is called.</li>
</ol>
<p>The basic resolution variable is the feed-in timer frequency. Having this update too sporadically will cause events scheduled to differing moments to be indistinguishable regarding their schedule (<em>e.g.</em>: most of the time, having the timer increment every 100ms will make any events scheduled to moments with less than 100ms of difference to each other to be run in the same runloop).</p>
<p>A good value for the timer ISR frequency is usually between 1 kHz - 200 Hz, but depending on project requirements and available resources it can be less. Down to around 10 Hz is still valid, but precision will start to deteriorate quickly from here on.</p>
<p>There is little use having the feed-in timer ISR run at more than 1 kHz, as it is meant to measure milliseconds. Software timers are unlikely to be accurate enough for much greater frequencies anyway.</p>
<p>If the <code>sch_manage_timers</code> function is not called frequently enough, events will start enqueuing and won't be served in time. Just make sure it is called when the counter is updated or when there are events on the schedule queue.</p>
<h3>Event loop</h3>
<p>The central piece of µEvLoop (even its name is a bloody reference to it) is the event loop, a queue of events to be processed sequentially. It is not aware of the execution time and simply process all enqueued events when run. Most heavy work in the system happens here.</p>
<p>The event loop requires access to system's internal pools and queues.</p>
<h4>Basic event loop initialisation</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-pools_8h.html">system/containers/system-pools.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-queues_8h.html">system/containers/system-queues.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="event-loop_8h.html">system/event-loop.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Create system containers</span></div><div class="line">syspools_t pools;</div><div class="line"><a class="code" href="system-pools_8h.html#a5b00c216720de7afc3a3c30a2df60cc4">syspools_init</a>(&amp;pools);</div><div class="line">sysqueues_t queues;</div><div class="line"><a class="code" href="system-queues_8h.html#abed67e4f7c2c8dec08899920bcf31a6a">sysqueues_init</a>(&amp;queues);</div><div class="line"></div><div class="line"><span class="comment">// Create the event loop</span></div><div class="line">evloop_t loop;</div><div class="line"><a class="code" href="event-loop_8h.html#afad64158ebb99c0ce26604c7b54148f3">evloop_init</a>(&amp;loop, &amp;pools, &amp;queues);</div></div><!-- fragment --><h4>Event loop usage</h4>
<p>The event loop is mean to behave as a run-to-completion task scheduler. Its <code>evloop_run</code> function should be called as often as possible as to minimise execution latency. Each execution of <code>evloop_run</code> is called a <em>runloop</em> .</p>
<p>The only way the programmer interacts with it, besides creation / initialisation, is by enqueuing hand-tailored closures directly, but other system modules operate on the event loop behind the stage.</p>
<p>Any closure can be enqueued multiple times.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="closure_8h.html">utils/closure.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *increment(closure_t *closure){</div><div class="line">  uintptr_t *value = (uintptr_t *)closure-&gt;context;</div><div class="line">  (*value)++;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">uintptr_t value = 0;</div><div class="line">closure_t closure = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;increment, (<span class="keywordtype">void</span> *)&amp;value, NULL);</div><div class="line"></div><div class="line"><a class="code" href="event-loop_8h.html#a9297808d7ffc05da6358ce6672221b27">evloop_enqueue_closure</a>(&amp;loop, &amp;closure);</div><div class="line"><span class="comment">// value is 0</span></div><div class="line"></div><div class="line"><a class="code" href="event-loop_8h.html#a342bd080e4ca3e4585437d7642d44ee2">evloop_run</a>(&amp;loop);  </div><div class="line"><span class="comment">// value is 1</span></div><div class="line"></div><div class="line"><a class="code" href="event-loop_8h.html#a9297808d7ffc05da6358ce6672221b27">evloop_enqueue_closure</a>(&amp;loop, &amp;closure);</div><div class="line"><a class="code" href="event-loop_8h.html#a9297808d7ffc05da6358ce6672221b27">evloop_enqueue_closure</a>(&amp;loop, &amp;closure);</div><div class="line"><a class="code" href="event-loop_8h.html#a342bd080e4ca3e4585437d7642d44ee2">evloop_run</a>(&amp;loop);</div><div class="line"><span class="comment">// value is 3</span></div></div><!-- fragment --><p> <em><b>WARNING!</b></em> <code>evloop_run</code> is the single most important function within µEvLoop. Almost every other core module depends on the event loop and if this function is not called, the loop won't work at all. Don't ever let it starve.</p>
<h3>Signal</h3>
<p>Signals are similar to events in Javascript. It allows the programmer to message distant parts of the system to communicate with each other in a pub/sub fashion.</p>
<p>At the centre of the signal <code>system</code> is the Signal Relay, a structure that bind speciffic signals to its listeners. When a signal is emitted, the relay will <b>asynchronously</b> run each listener registered for that signal. If the listener was not recurring, it will be destroyed upon execution by the event loop.</p>
<h4>Signals and relay initialisation</h4>
<p>To use signals, the programmer must first define what signals will be available in a particular relay, then create the relay bound to this events.</p>
<p>To be initialised, the relay must have access to the system's internal pools and queues. The programmer will also need to supply it a buffer of <a href="#linked-lists">linked lists</a>, where listeners will be stored.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-pools_8h.html">system/containers/system-pools.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system-queues_8h.html">system/containers/system-queues.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="signal_8h.html">system/signal.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="linked-list_8h.html">utils/linked-list.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Create the system containers</span></div><div class="line">syspools_t pools;</div><div class="line"><a class="code" href="system-pools_8h.html#a5b00c216720de7afc3a3c30a2df60cc4">syspools_init</a>(&amp;pools);</div><div class="line">sysqueues_t queues;</div><div class="line"><a class="code" href="system-queues_8h.html#abed67e4f7c2c8dec08899920bcf31a6a">sysqueues_init</a>(&amp;queues);</div><div class="line"></div><div class="line"><span class="comment">// Define what signals will be available to this relay.</span></div><div class="line"><span class="comment">// Doing so in an enum makes it easy to add new signals in the future.</span></div><div class="line"><span class="keyword">enum</span> my_module_signals {</div><div class="line">  SIGNAL_1 = 0,</div><div class="line">  SIGNAL_2,</div><div class="line">  SIGNAL_COUNT</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare the relay buffer. Note this array will be the number of signals large.</span></div><div class="line">llist_t buffer[SIGNAL_COUNT];</div><div class="line"></div><div class="line"><span class="comment">// Create the relay</span></div><div class="line">signal_relay_t relay;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="signal_8h.html#a32a5c7105320c8e7437d8a36fda4899b">signal_relay_init</a>(&amp;relay, &amp;pools, &amp;queues, buffer, SIGNAL_COUNT);</div></div><!-- fragment --><h4>Signal operation</h4>
<div class="fragment"><div class="line"><span class="comment">// This is the listener function.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *respond_to_signal(closure_t *closure){</div><div class="line">  uintptr_t num = (uintptr_t)closure-&gt;context;</div><div class="line">  <span class="comment">// Signals can be emitted with parameters, just like events in JS</span></div><div class="line">  <span class="keywordtype">char</span> c = (<span class="keywordtype">char</span>)(uintptr_t)closure-&gt;params;</div><div class="line">  printf(<span class="stringliteral">&quot;%d%c\n&quot;</span>, num, c);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Listeners can be persistent. They will fire once each time the signal is emitted</span></div><div class="line">closure_t respond_to_signal_1 = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;respond_to_signal, (<span class="keywordtype">void</span> *)1, NULL);</div><div class="line"><a class="code" href="signal_8h.html#a9ae986ba3dd3166e3c542762bb8b0ce5">signal_listener_t</a> listener_1 =</div><div class="line">  <a class="code" href="signal_8h.html#ab16f22b1d4dc97a45dd8ecee8d3d716c">signal_listen</a>(SIGNAL_1, &amp;relay, &amp;respond_to_signal_1);</div><div class="line"></div><div class="line"><span class="comment">// Listeners can also be transient, so they fire ust on first emission</span></div><div class="line">closure_t respond_to_signal_2 = <a class="code" href="closure_8h.html#a8c157177875ca46ce9e85b70d7a0d7d1">closure_create</a>(&amp;respond_to_signal, (<span class="keywordtype">void</span> *)2, NULL);</div><div class="line"><a class="code" href="signal_8h.html#a9ae986ba3dd3166e3c542762bb8b0ce5">signal_listener_t</a> listener_2 =</div><div class="line">  <a class="code" href="signal_8h.html#abf0d5feed25c08e6826ae5849360cc4f">signal_listen_once</a>(SIGNAL_2, &amp;relay, &amp;respond_to_signal_2);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><a class="code" href="signal_8h.html#a04a8eb14d33a3bd88b017c49d2d241ae">signal_emit</a>(SIGNAL_1, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;a&#39;</span>)); <span class="comment">// prints 1a</span></div><div class="line"><a class="code" href="signal_8h.html#a04a8eb14d33a3bd88b017c49d2d241ae">signal_emit</a>(SIGNAL_2, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;b&#39;</span>)); <span class="comment">// prints 2b</span></div><div class="line"><a class="code" href="signal_8h.html#a04a8eb14d33a3bd88b017c49d2d241ae">signal_emit</a>(SIGNAL_1, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;c&#39;</span>)); <span class="comment">// prints 1c</span></div><div class="line"><a class="code" href="signal_8h.html#a04a8eb14d33a3bd88b017c49d2d241ae">signal_emit</a>(SIGNAL_2, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;d&#39;</span>)); <span class="comment">// doesn&#39;t print anything</span></div></div><!-- fragment --><p>Please note the listener function will not be executed immediately, despite what this last snippet can lead to believe. Internally, each closure will be sent to the event loop and only when it runs will the closures be invoked.</p>
<p>You can also unlisten for events. This will prevent the listener returned by a <code><a class="el" href="signal_8h.html#ab16f22b1d4dc97a45dd8ecee8d3d716c" title="Attaches a listener closure to some signal at a particular relay. ">signal_listen()</a></code> or <code><a class="el" href="signal_8h.html#abf0d5feed25c08e6826ae5849360cc4f" title="Attaches a listener closure to some signal at a particular relay. The listener closure will be invoke...">signal_listen_once()</a></code> operation to have its closure invoked when the <a href="#event-loop">event loop</a> performs the next runloop. Additionally, said listener will be removed from the signal vector on such opportunity.</p>
<div class="fragment"><div class="line"><a class="code" href="signal_8h.html#a4d1a8cde3b250148801339fc72ff11a4">signal_unlisten</a>(listener_1, &amp;relay);</div><div class="line"><a class="code" href="signal_8h.html#a4d1a8cde3b250148801339fc72ff11a4">signal_unlisten</a>(listener_2, &amp;relay);  <span class="comment">// This has no effect because the listener</span></div><div class="line">                                      <span class="comment">// for SIGNAL_2 has already been marked as unlistened</span></div></div><!-- fragment --><h2>Concurrency model</h2>
<p>µEvLoop is meant to run baremetal, primarily in simple single-core MCUs. That said, nothing stops it from being employed as a side library in RTOSes or in full-fledged x86_64 multi-threaded desktop applications.</p>
<p>Communication between asynchronous contexts, such as ISRs and side threads, is done through some shared data structures defined inside the library's core modules. As whenever dealing with non-atomic shared memory, there must be sincronisation between accesses to these structures as to avoid memory corruption.</p>
<p>µEvLoop does not try to implement a universal locking scheme fit for any device. Instead, some generic critical section definition is provided.</p>
<h3>Critical sections</h3>
<p>By default, critical sections in µEvLoop are a no-op. They are provided as a set of macros that can be overriden by the programmer to implement platform speciffic behaviour.</p>
<p>For instance, while running baremetal it may be only necessary to disable interrupts to make sure accesses are synchronised. On a RTOS multi-threaded environment, on the other hand, it may be necessary to use a mutex.</p>
<p>There are three macros that define critical section implementation:</p>
<ol type="1">
<li><p class="startli"><code>UEVLOOP_CRITICAL_SECTION_OBJ_TYPE</code></p>
<p class="startli">If needed, a global critical section object can be declared. If this macro is defined, this object will be available to any critical section under the symbol <code>uevloop_critical_section</code>.</p>
<p class="startli">The <code>UEVLOOP_CRITICAL_SECTION_OBJ_TYPE</code> macro defines the <b>type</b> of the object. It is the programmer's responsibility to declare the globally allocate and initialise the object.</p>
</li>
<li><p class="startli"><code>UEVLOOP_CRITICAL_ENTER</code></p>
<p class="startli">Enters a new critical section. From this point until the critical section exits, no other thread or ISR may attempt to access the system's shared memory.</p>
</li>
<li><p class="startli"><code>UEVLOOP_CRITICAL_EXIT</code></p>
<p class="startli">Exits the current critical section. After this is called, any shared memory is allowed to be claimed by some party.</p>
</li>
</ol>
<h2>Motivation</h2>
<p>I often work with small MCUs (8-16bits) that simply don't have the necessary power to run a RTOS ou any fancy scheduling solution. Right now I am working on a new comercial project and felt the need to build something by my own. µEvLoop is my bet on how a modern, interrupt-driven and predictable embedded application should be. I am also looking for a new job and needed to improve my portifolio.</p>
<h2>Roadmap</h2>
<ul>
<li>~~Correct some bugs I am aware of~~</li>
<li>~~Comment code and generate API doc~~</li>
<li>Make timer events cancellable / pausable / resumable</li>
<li>Better error handling </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
