<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>µEvLoop: µEvLoop &lt;img src=&quot;https://github.com/andsmedeiros/uevloop/workflows/C/C++%20CI/badge.svg?event=push&quot; alt=&quot;C/C++ CI&quot;/&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">µEvLoop
   </div>
   <div id="projectbrief">A fast and lightweight event loop aimed at embedded platforms in C99.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">µEvLoop <object type="image/svg+xml" data="https://github.com/andsmedeiros/uevloop/workflows/C/C++%20CI/badge.svg?event=push" style="pointer-events: none;">C/C++ CI</object> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A fast and lightweight event loop aimed at embedded platforms in C99.</p>
<ul>
<li><a href="#about">About</a><ul>
<li><a href="#disclaimer"><em>DISCLAIMER</em></a></li>
</ul>
</li>
<li><a href="#highlights">Highlights</a></li>
<li><a href="#api-documentation">API documentation</a></li>
<li><a href="#testing">Testing</a><ul>
<li><a href="#test-coverage">Test coverage</a></li>
</ul>
</li>
<li><a href="#core-data-structures">Core data structures</a><ul>
<li><a href="#closures">Closures</a><ul>
<li><a href="#basic-closure-usage">Basic closure usage</a></li>
<li><a href="#a-word-on-void-">A word on (void *)</a></li>
</ul>
</li>
<li><a href="#circular-queues">Circular queues</a><ul>
<li><a href="#basic-circular-queue-usage">Basic circular queue usage</a></li>
</ul>
</li>
<li><a href="#object-pools">Object pools</a><ul>
<li><a href="#basic-object-pool-usage">Basic object pool usage</a></li>
</ul>
</li>
<li><a href="#linked-lists">Linked lists</a><ul>
<li><a href="#basic-linked-list-usage">Basic linked list usage</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#containers">Containers</a><ul>
<li><a href="#system-pools">System pools</a><ul>
<li><a href="#system-pools-usage">System pools usage</a></li>
</ul>
</li>
<li><a href="#system-queues">System queues</a><ul>
<li><a href="#system-queues-usage">System queues usage</a></li>
</ul>
</li>
<li><a href="#application">Application</a><ul>
<li><a href="#application-registry">Application registry</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core-components">Core components</a><ul>
<li><a href="#scheduler">Scheduler</a><ul>
<li><a href="#basic-scheduler-initialisation">Basic scheduler initialisation</a></li>
<li><a href="#scheduler-operation">Scheduler operation</a></li>
<li><a href="#timer-events">Timer events</a></li>
<li><a href="#scheduler-time-resolution">Scheduler time resolution</a></li>
</ul>
</li>
<li><a href="#event-loop">Event loop</a><ul>
<li><a href="#basic-event-loop-initialisation">Basic event loop initialisation</a></li>
<li><a href="#event-loop-usage">Event loop usage</a></li>
<li><a href="#observers">Observers</a></li>
</ul>
</li>
<li><a href="#signal">Signal</a><ul>
<li><a href="#signals-and-relay-initialisation">Signals and relay initialisation</a></li>
<li><a href="#signal-operation">Signal operation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix-a-promises">Appendix A: Promises</a><ul>
<li><a href="#promise-stores">Promise stores</a><ul>
<li><a href="#promise-store-creation">Promise store creation</a></li>
</ul>
</li>
<li><a href="#promises-and-segments">Promises and segments</a><ul>
<li><a href="#promise-creation">Promise creation</a></li>
<li><a href="#promise-settling">Promise settling</a></li>
<li><a href="#segments">Segments</a></li>
<li><a href="#segment-chains-and-promise-resettling">Segment chains and promise resettling</a></li>
<li><a href="#nested-promises">Nested promises</a></li>
<li><a href="#promise-destroying-and-promise-helpers">Promise destroying and promise helpers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix-b-modules">Appendix B: Modules</a><ul>
<li><a href="#module-creation">Module creation</a></li>
<li><a href="#module-registration">Module registration</a></li>
<li><a href="#dependency-injection">Dependency Injection</a><ul>
<li><a href="#parametrised-injection">Parametrised injection</a></li>
<li><a href="#ad-hoc-injection">Ad-hoc injection</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix-c-useful-goodies">Appendix C: Useful goodies</a><ul>
<li><a href="#iterators">Iterators</a><ul>
<li><a href="#array-iterators">Array iterators</a></li>
<li><a href="#linked-list-iterators">Linked list iterators</a></li>
<li><a href="#iterator-operation">Iterator operation</a></li>
<li><a href="#iteration-helpers">Iteration helpers</a></li>
<li><a href="#custom-iterators">Custom iterators</a></li>
</ul>
</li>
<li><a href="#conditionals">Conditionals</a></li>
<li><a href="#pipelines">Pipelines</a></li>
<li><a href="#functional-helpers">Functional helpers</a></li>
<li><a href="#automatic-pools-and-automatic-pointers">Automatic pools and automatic pointers</a><ul>
<li><a href="#automatic-pool-creation">Automatic pool creation</a></li>
<li><a href="#automatic-pool-operation-and-automatic-pointer-destruction">Automatic pool operation and automatic pointer destruction</a></li>
<li><a href="#automatic-pool-constructors-and-destructors">Automatic pool constructors and destructors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#concurrency-model">Concurrency model</a><ul>
<li><a href="#critical-sections">Critical sections</a></li>
</ul>
</li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#roadmap">Roadmap</a></li>
</ul>
<h1>About</h1>
<p>µEvLoop is a microframework build around a lightweight event loop. It provides the programmer the building blocks to put together async, interrupt-based systems.</p>
<p>µEvLoop is loosely inspired on the Javascript event loop and aims to provide a similar programming model. Many similar concepts, such as events and closures are included. It is aimed at environments with very restricted resources, but can be run on all kinds of platforms.</p>
<h2>*DISCLAIMER*</h2>
<p>µEvLoop is in its early days and the API may change at any moment for now. Although it's well tested, use it with caution. Anyway, feedback is most welcome.</p>
<h1>Highlights</h1>
<ul>
<li>As minimalist and loose-coupled as possible.</li>
<li>Does not allocate any dynamic memory on its own. All memory needed is statically allocated either explicitly by the user or implicitly by <a href="#containers">containers</a>.</li>
<li>Small memory footprint and runtime latency.</li>
<li>Does not try to make assumptions about the underlying system.</li>
<li>Extremely portable and conforming to ISO C99.</li>
<li>Depends only on a very small subset of the standard libc, mostly for fixed size integers and booleans.</li>
<li>Allows for excellent execution predictability and ease of debugging.</li>
<li>Can be used baremetal or alongside RTOSes.</li>
<li>Well tested and well documented.</li>
</ul>
<h1>API documentation</h1>
<p>The API documentation is automatically generated by Doxygen. Find it <a href="https://andsmedeiros.github.io/uevloop/">here</a>.</p>
<h1>Testing</h1>
<p>Tests are written using a simple set of macros. To run them, execute <code>make test</code>.</p>
<p>Please note that the makefile shipped is meant to be run in modern Linux systems. Right now, it makes use of bash commands and utilities as well as expects <code>libSegFault.so</code> to be in a hardcoded path.</p>
<p>If this doesn't fit your needs, edit it as necessary.</p>
<h2>Test coverage</h2>
<p>To generate code coverage reports, run <code>make coverage</code>. This requires <code>gcov</code>, <code>lcov</code> and <code>genhtml</code> to be on your <code>PATH</code>. After running, the results can be found on <code>uevloop/coverage/index.html</code>.</p>
<h1>Core data structures</h1>
<p>These data structures are used across the whole framework. They can also be used by the programmer in userspace as required.</p>
<p><b>All core data structures are unsafe. Be sure to wrap access to them in <a href="#critical-sections">critical sections</a> if you mean to share them amongst contexts asynchronous to each other.</b></p>
<h2>Closures</h2>
<p>A closure is an object that binds a function to some context. When invoked with arbitrary parameters, the bound function is called with both context and parameters available. With closures, some very powerful programming patterns, as functional composition, become way easier to implement.</p>
<p>Closures are very light and it is often useful to pass them around by value.</p>
<h3>Basic closure usage</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="closure_8h.html">uevloop/utils/closure.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *add(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uintptr_t value1 = (uintptr_t)context;</div>
<div class="line">    uintptr_t value2 = (uintptr_t)params;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(value1 + value2);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Binds the function `add` to the context (5)</span></div>
<div class="line">uel_closure_t add_five = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;add, (<span class="keywordtype">void</span> *)5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Invokes the closure with the parameters set to (2)</span></div>
<div class="line">uintptr_t result = (uintptr_t)<a class="code" href="closure_8h.html#adcd44820dd3715e206fdf71800e8926c">uel_closure_invoke</a>(&amp;add_five, (<span class="keywordtype">void</span> *)2);</div>
<div class="line"><span class="comment">// Result is 7</span></div>
</div><!-- fragment --><h3>A word on (void *)</h3>
<p>Closures take the context and parameters as a void pointers and return the same. This is meant to make possible to pass and return complex objects from them.</p>
<p>At many times, however, the programmer may find the values passed/returned are small and simple (<em>i.e.</em>: smaller than a pointer). If so, it is absolutely valid to cast from/to a <code>uintptr_t</code> or other data type known to be at most the size of a pointer. The above example does that to avoid creating unnecessary object pools or allocating dynamic memory.</p>
<h2>Circular queues</h2>
<p>Circular queues are fast FIFO (<em>first-in-first-out</em>) structures that rely on a pair of indices to maintain state. As the indices are moved forward on push/pop operations, the data itself is not moved at all.</p>
<p>The size of µEvLoop's circular queues are <b>required</b> to be powers of two, so it is possible to use fast modulo-2 arithmetic. As such, on queue creation, the size <b>must</b> be provided in its log2 form.</p>
<p><em><b>FORGETTING TO SUPPLY THE QUEUE'S SIZE IN LOG2 FORM MAY CAUSE THE STATIC ALLOCATION OF GIANT MEMORY POOLS</b></em></p>
<h3>Basic circular queue usage</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="circular-queue_8h.html">uevloop/utils/circular-queue.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE_LOG2N   (5)</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE         (1&lt;&lt;BUFFER_SIZE_LOG2N)  // 1&lt;&lt;5 == 2**5 == 32</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">uel_cqueue_t queue;</div>
<div class="line"><span class="keywordtype">void</span> *buffer[BUFFER_SIZE];</div>
<div class="line"><span class="comment">// Creates a queue with 32 (2**5) slots</span></div>
<div class="line"><a class="code" href="circular-queue_8h.html#acf451cae31642c456faada2501a4977e">uel_cqueue_init</a>(&amp;queue, buffer, BUFFER_SIZE_LOG2N);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Push items in the queue</span></div>
<div class="line"><a class="code" href="circular-queue_8h.html#ae65acd13845cdd8e2492201538c2e968">uel_cqueue_push</a>(&amp;queue, (<span class="keywordtype">void</span> *)3)</div>
<div class="line"><a class="code" href="circular-queue_8h.html#ae65acd13845cdd8e2492201538c2e968">uel_cqueue_push</a>(&amp;queue, (<span class="keywordtype">void</span> *)2)</div>
<div class="line"><a class="code" href="circular-queue_8h.html#ae65acd13845cdd8e2492201538c2e968">uel_cqueue_push</a>(&amp;queue, (<span class="keywordtype">void</span> *)1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pop items from the queue</span></div>
<div class="line">uintptr_t value1 = (uintptr_t) <a class="code" href="circular-queue_8h.html#a818331aa6bf56e977f7a95d996e9009d">uel_cqueue_pop</a>(&amp;queue); <span class="comment">// value1 is 3</span></div>
<div class="line">uintptr_t value2 = (uintptr_t) <a class="code" href="circular-queue_8h.html#a818331aa6bf56e977f7a95d996e9009d">uel_cqueue_pop</a>(&amp;queue); <span class="comment">// value2 is 2</span></div>
<div class="line">uintptr_t value3 = (uintptr_t) <a class="code" href="circular-queue_8h.html#a818331aa6bf56e977f7a95d996e9009d">uel_cqueue_pop</a>(&amp;queue); <span class="comment">// value3 is 1</span></div>
</div><!-- fragment --><p>Circular queues store void pointers. As it is the case with closures, this make possible to store complex objects within the queue, but often typecasting to an smaller value type is more useful.</p>
<h2>Object pools</h2>
<p>On embedded systems, hardware resources such as processing power or RAM memory are often very limited. As a consequence, dynamic memory management can become very expensive in both aspects.</p>
<p>Object pools are statically allocated arrays of objects whose addresses are stored in a queue. Whenever the programmer needs a object in runtime, instead of dynamically allocating memory, it is possible to simply pop an object pointer from the pool and use it away.</p>
<p>Because object pools are statically allocated and backed by <a href="#circular-queues">circular queues</a>, they are very manageable and fast to operate.</p>
<h3>Basic object pool usage</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="object-pool_8h.html">uevloop/utils/object-pool.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>obj obj_t;</div>
<div class="line"><span class="keyword">struct </span>obj {</div>
<div class="line">    uint32_t num;</div>
<div class="line">    <span class="keywordtype">char</span> str[32];</div>
<div class="line">    <span class="comment">// Whatever</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The log2 of our pool size.</span></div>
<div class="line"><span class="preprocessor">#define POOL_SIZE_LOG2N   (5)</span></div>
<div class="line"><a class="code" href="object-pool_8h.html#a6f94946d39d323f7ea0f409962c59f1e">UEL_DECLARE_OBJPOOL_BUFFERS</a>(obj_t, POOL_SIZE_LOG2N, my_pool);</div>
<div class="line"> </div>
<div class="line">uel_objpool_t my_pool;</div>
<div class="line"><a class="code" href="object-pool_8h.html#ab49dd047b6e4fcc0939dfd651e3b3666">uel_objpool_init</a>(&amp;my_pool, POOL_SIZE_LOG2N, <span class="keyword">sizeof</span>(obj_t), <a class="code" href="object-pool_8h.html#a623ea70a0df4cc76d0e65a99bc5c26c9">UEL_OBJPOOL_BUFFERS</a>(my_pool));</div>
<div class="line"><span class="comment">// my_pool now is a pool with 32 (2**5) obj_t</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Whenever the programmer needs a fresh obj_t</span></div>
<div class="line">obj_t *obj = (obj_t *)<a class="code" href="object-pool_8h.html#a54248e0810ccb791a8ff82d3de8fc6c5">uel_objpool_acquire</a>(&amp;my_pool);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When it is no longer needed, return it to the pool</span></div>
<div class="line"><a class="code" href="object-pool_8h.html#af4370a164b82e436749fbc9f8af9a114">uel_objpool_release</a>(&amp;my_pool, obj);</div>
</div><!-- fragment --><h2>Linked lists</h2>
<p>µEvLoop ships a simple linked list implementation that holds void pointers, as usual.</p>
<h3>Basic linked list usage</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stddef.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linked-list_8h.html">uevloop/utils/linked-list.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uel_llist_t list;</div>
<div class="line"><a class="code" href="linked-list_8h.html#a636d9d433df7fd53fc3138b6c77df75a">uel_llist_init</a>(&amp;list);</div>
<div class="line"> </div>
<div class="line">uel_llist_node_t nodes[2] = {</div>
<div class="line">    {(<span class="keywordtype">void</span> *)1, NULL},</div>
<div class="line">    {(<span class="keywordtype">void</span> *)2, NULL}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Push items into the list</span></div>
<div class="line"><a class="code" href="linked-list_8h.html#a0a98f53f55f86adb45e4f0f357d748a8">uel_llist_push_head</a>(&amp;list, &amp;nodes[0]);</div>
<div class="line"><a class="code" href="linked-list_8h.html#a0a98f53f55f86adb45e4f0f357d748a8">uel_llist_push_head</a>(&amp;list, &amp;nodes[1]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// List now is TAIL-&gt; [1]-&gt; [2]-&gt; NULL. HEAD-&gt; [2]</span></div>
<div class="line">uel_llist_node_t *node1 = (uel_llist_node_t *)llist_pop_tail(&amp;list);</div>
<div class="line">uel_llist_node_t *node2 = (uel_llist_node_t *)llist_pop_tail(&amp;list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//node1 == nodes[0] and node2 == nodes[1]</span></div>
</div><!-- fragment --><h1>Containers</h1>
<p>Containers are objects that encapsulate declaration, initialisation and manipulation of core data structures used by the framework.</p>
<p>They also encapsulates manipulation of these data structures inside <a href="#critical-sections">critical sections</a>, ensuring safe access to shared resources across the system.</p>
<h2>System pools</h2>
<p>The <code>syspools</code> component is a container for the system internal object pools. It contains pools for events and linked list nodes used by the core components.</p>
<p>The system pools component is meant to be internally operated only. The only responsibility of the programmer is to allocate, initialise and provide it to other core components.</p>
<p>To configure the size of each pool created, edit <code><a class="el" href="config_8h.html" title="Central repository of system configuration. This is meant to be edited by the programmer as needed.">include/uevloop/config.h</a></code>.</p>
<h3>System pools usage</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="system-pools_8h.html">uevloop/system/containers/system-pools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uel_syspools_t pools;</div>
<div class="line"><a class="code" href="system-pools_8h.html#a737df9d7ca7c587711dc8c59d9f1c277">uel_syspools_init</a>(&amp;pools);</div>
<div class="line"><span class="comment">// This allocates two pools:</span></div>
<div class="line"><span class="comment">//   1) pools.event_pool</span></div>
<div class="line"><span class="comment">//   2) pools.llist_node_pool</span></div>
</div><!-- fragment --><h2>System queues</h2>
<p>The <code>sysqueues</code> component contains the necessary queues for sharing data amongst the core components. It holds queues for events in differing statuses.</p>
<p>As is the case with system pools, the <code>sysqueues</code> component should not be directly operated by the programmer, except for declaration and initialisation.</p>
<p>Configure the size of each queue created in <code><a class="el" href="config_8h.html" title="Central repository of system configuration. This is meant to be edited by the programmer as needed.">include/uevloop/config.h</a></code>.</p>
<h3>System queues usage</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="system-queues_8h.html">uevloop/system/containers/system-queues.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uel_sysqueues_t queues;</div>
<div class="line"><a class="code" href="system-queues_8h.html#aa988e6daddfd00129d56c1db350edc5a">uel_sysqueues_init</a>(&amp;queues);</div>
<div class="line"><span class="comment">// This allocates two queues:</span></div>
<div class="line"><span class="comment">//   1) queues.event_queue (events ready to be processed are put here)</span></div>
<div class="line"><span class="comment">//   2) queues.schedule_queue (events ready to be scheduled are put here)</span></div>
</div><!-- fragment --><h2>Application</h2>
<p>The <code>application</code> component is a convenient top-level container for all the internals of an µEvLoop'd app. It is not necessary at all but contains much of the boilerplate in a typical application.</p>
<p>It also proxies functions to the <a href="#event-loop"><code>event loop</code></a> and <a href="#scheduler"><code>scheduler</code></a> components, serving as a single point entry for the system operation.</p>
<p>The following code is a realistic minimal setup of the framework. ```c #include &lt;<a class="el" href="application_8h.html" title="The application module is a convenient top-level container for the system internals.">uevloop/system/containers/application.h</a>&gt; #include &lt;stdint.h&gt;</p>
<p>static volatile uint32_t counter = 0; static uel_application_t my_app;</p>
<p>// 1 kHz timer void my_timer_isr(){ my_timer_isr_flag = 0; uel_app_update_timer(&amp;my_app, ++counter); }</p>
<p>int main (int argc, char *argv[]){ uel_app_init(&amp;my_app);</p>
<p>// From here, the programmer can: // - Schedule timers with <code>uel_app_run_later</code> or <code>uel_app_run_at_intervals</code> // - Enqueue closures with <code>uel_app_enqueue_closure</code> // - Set up observers with <code>uel_app_observe</code> // - Listen for signals set at other places</p>
<p>while(1){ <br  />
 uel_app_tick(&amp;my_app); }</p>
<p>return 0; } </p><div class="fragment"><div class="line">#### Application registry</div>
<div class="line"> </div>
<div class="line">The `application` component can also keep a registry of modules to manage. See [Appendix A: Modules](#appendix-a-modules) for more information.</div>
<div class="line"> </div>
<div class="line">## Core components</div>
<div class="line"> </div>
<div class="line">### Scheduler</div>
<div class="line"> </div>
<div class="line">The scheduler is a component that keeps track of current execution time and closures to be run in the future. It provides similar functionality to the `setTimeout` and `setInterval` Javascript functions.</div>
<div class="line"> </div>
<div class="line">Two queues lead in and out of it: the inbound schedule_queue is externally fed events that should be scheduled and then accounted for; the outbound event_queue hold events that are due to be collected and processed.</div>
<div class="line"> </div>
<div class="line">This component needs access to system&#39;s pools and queues.</div>
<div class="line"> </div>
<div class="line">#### Basic scheduler initialisation</div>
<div class="line"> </div>
<div class="line">```c</div>
<div class="line">#include &lt;uevloop/system/containers/system-pools.h&gt;</div>
<div class="line">#include &lt;uevloop/system/containers/system-queues.h&gt;</div>
<div class="line">#include &lt;uevloop/system/scheduler.h&gt;</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">// Create the system containers</div>
<div class="line">uel_syspools_t pools;</div>
<div class="line">uel_syspools_init(&amp;pools);</div>
<div class="line">uel_sysqueues_t queues;</div>
<div class="line">uel_sysqueues_init(&amp;queues);</div>
<div class="line"> </div>
<div class="line">// Create the scheduler</div>
<div class="line">uel_scheduer_t scheduler;</div>
<div class="line">uel_sch_init(&amp;scheduler, &amp;pools, &amp;queues);</div>
</div><!-- fragment --><h3>Scheduler operation</h3>
<p>The <code>scheduler</code> component accepts input of closures and scheduling info an then turns it into a timer event. This timer is then inserted in a timer list, which is sorted by each timer's due time.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="closure_8h.html">uevloop/utils/closure.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *print_coords(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uintptr_t x = (uintptr_t)context;</div>
<div class="line">    uintptr_t y = (uintptr_t)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;(x: %d, y: %d)\n&quot;</span>, x, y);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uel_closure_t  print_x_one = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;print_coords, (<span class="keywordtype">void</span> *)1);</div>
<div class="line">uel_closure_t  print_x_two = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;print_coords, (<span class="keywordtype">void</span> *)2);</div>
<div class="line">uel_closure_t  print_x_three = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;print_coords, (<span class="keywordtype">void</span> *)3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Schedules to run 1000ms in the future.</span></div>
<div class="line"><span class="comment">// Will print (x: 1, y: 4)</span></div>
<div class="line"><a class="code" href="scheduler_8h.html#ad5909fddc1856cc1b980a0445602c67c">uel_sch_run_later</a>(&amp;scheduler, 1000, print_x_one, (<span class="keywordtype">void</span> *)4);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Schedules to run at intervals of 500ms, runs the first time after 500ms</span></div>
<div class="line"><span class="comment">// Will print (x: 2, y: 5)</span></div>
<div class="line"><a class="code" href="scheduler_8h.html#a6a993056042a7649e1e7375eb2bb588d">uel_sch_run_at_intervals</a>(&amp;scheduler, 500, <span class="keyword">false</span>, print_x_two, (<span class="keywordtype">void</span> *)5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Schedules to run at intervals of 300ms, runs the first time the next runloop</span></div>
<div class="line"><span class="comment">// Will print (x: 3, y: 6)</span></div>
<div class="line"><a class="code" href="scheduler_8h.html#a6a993056042a7649e1e7375eb2bb588d">uel_sch_run_at_intervals</a>(&amp;scheduler, 300, <span class="keyword">true</span>, print_x_three, (<span class="keywordtype">void</span> *)6);</div>
</div><!-- fragment --><p>The <code>scheduler</code> must be fed regularly to work. It needs both an update on the running time as an stimulus to process enqueued timers. Ideally, a hardware timer will be consistently incrementing a counter and feeding it at an ISR while in the main loop the scheduler is oriented to process its queue.</p>
<div class="fragment"><div class="line"><span class="comment">// millisecond counter</span></div>
<div class="line"><span class="keyword">volatile</span> uint32_t counter = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1kHz timer ISR</span></div>
<div class="line"><span class="keywordtype">void</span> my_timer_isr(){</div>
<div class="line">    my_timer_isr_flag = 0;</div>
<div class="line">    <a class="code" href="scheduler_8h.html#a0a5a89adf45a470aed0e39925a256ea2">uel_sch_update_timer</a>(&amp;scheduler, ++counter);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// On the main loop</span></div>
<div class="line"><a class="code" href="scheduler_8h.html#a2666a61c55a518fd602cee03a014ed10">uel_sch_manage_timers</a>(&amp;scheduler);</div>
</div><!-- fragment --><p>When the function <code>uel_sch_manage_timers</code> is called, two things happen:</p><ol type="1">
<li>The <code>schedule_queue</code> is flushed and every timer in it is scheduled accordingly;</li>
<li>The scheduler iterates over the scheduled timer list from the beginning and breaks it when it finds a timer scheduled further in the future. It then proceeds to move each timer from the extracted list to the <code>event_queue</code>, where they will be further collected and processed.</li>
</ol>
<h3>Timer events</h3>
<p>Events are messages passed amongst the system internals that coordinate what tasks are to be run, when and in which order. Usually, the programmer don't have to interact directly with events, being <em>timer events</em> and <a href="#observers">observers</a> the only exceptions to this. The functions <code>uel_sch_run_later</code> and <code>uel_sch_run_at_intervals</code> return a <code>uel_event_t *</code>. With this handle, it is possible to pause and resume or even completely cancel a timer event.</p>
<p>```C #include &lt;stddef.h&gt;</p>
<p>uel_event_t *timer = uel_sch_run_at_intervals(&amp;scheduler, 100, false, print_one, NULL);</p>
<p>// The event will be put on a hold queue in the scheduler uel_event_timer_pause(timer); <br  />
</p>
<p>// The event will be rescheduled on the scheduler uel_event_timer_resume(timer);</p>
<p>// The event will be ignored by the scheduler and destroyed at the <code>event loop</code> uel_event_timer_cancel(timer); </p><div class="fragment"><div class="line">When pausing and resuming timer events, be aware of the internal&#39;s latencies: paused timers are only sent to the hold queue when their  scheduled time is hit. Also, when resumed, they are scheduled based solely on their period setting, being the elapsed time when they were paused completely ignored. Should a timer both scheduled *and* paused be resumed *before* its elapsed time is hit, it behaves as it was never paused.</div>
<div class="line">Regarding cancelled timer events, they are equally susceptible to internal latency as they will only be destroyed when processed by the `event loop`. However, cancelled timers are not meant to be reused anyway. As a rule of thumb, **never** use a timer event after it was cancelled.</div>
<div class="line"> </div>
<div class="line">#### Scheduler time resolution</div>
<div class="line"> </div>
<div class="line">There are two distinct factors that will determine the actual time resolution of the scheduler:</div>
<div class="line">1. the frequency of the feed in timer ISR</div>
<div class="line">2.  the frequency the function `uel_sch_manage_timers` is called.</div>
<div class="line"> </div>
<div class="line">The basic resolution variable is the feed-in timer frequency. Having this update too sporadically will cause events scheduled to differing moments to be indistinguishable regarding their schedule (*e.g.*: most of the time, having the timer increment every 100ms will make any events scheduled to moments with less than 100ms of difference to each other to be run in the same runloop).</div>
<div class="line"> </div>
<div class="line">A good value for the timer ISR frequency is usually between 1 kHz - 200 Hz, but depending on project requirements and available resources it can be less. Down to around 10 Hz is still valid, but precision will start to deteriorate quickly from here on.</div>
<div class="line"> </div>
<div class="line">There is little use having the feed-in timer ISR run at more than 1 kHz, as it is meant to measure milliseconds. Software timers are unlikely to be accurate enough for much greater frequencies anyway.</div>
<div class="line"> </div>
<div class="line">If the `uel_sch_manage_timers` function is not called frequently enough, events will start enqueuing and won&#39;t be served in time. Just make sure it is called when the counter is updated or when there are events on the schedule queue.</div>
<div class="line"> </div>
<div class="line">### Event loop</div>
<div class="line"> </div>
<div class="line">The central piece of µEvLoop (even its name is a bloody reference to it) is the event loop, a queue of events to be processed sequentially. It is not aware of the execution time and simply process all enqueued events when run. Most heavy work in the system happens here.</div>
<div class="line"> </div>
<div class="line">The event loop requires access to system&#39;s internal pools and queues.</div>
<div class="line"> </div>
<div class="line">#### Basic event loop initialisation</div>
<div class="line"> </div>
<div class="line">```c</div>
<div class="line">#include &lt;uevloop/system/containers/system-pools.h&gt;</div>
<div class="line">#include &lt;uevloop/system/containers/system-queues.h&gt;</div>
<div class="line">#include &lt;uevloop/system/event-loop.h&gt;</div>
<div class="line"> </div>
<div class="line">// Create system containers</div>
<div class="line">uel_syspools_t pools;</div>
<div class="line">uel_syspools_init(&amp;pools);</div>
<div class="line">uel_sysqueues_t queues;</div>
<div class="line">uel_sysqueues_init(&amp;queues);</div>
<div class="line"> </div>
<div class="line">// Create the event loop</div>
<div class="line">uel_evloop_t loop;</div>
<div class="line">uel_evloop_init(&amp;loop, &amp;pools, &amp;queues);</div>
</div><!-- fragment --><h3>Event loop usage</h3>
<p>The event loop is mean to behave as a run-to-completion task scheduler. Its <code>uel_evloop_run</code> function should be called as often as possible as to minimise execution latency. Each execution of <code>uel_evloop_run</code> is called a <em>runloop</em> .</p>
<p>The only way the programmer interacts with it, besides creation / initialisation, is by enqueuing hand-tailored closures directly, but other system components operate on the event loop behind the stage.</p>
<p>Any closure can be enqueued multiple times.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="closure_8h.html">uevloop/utils/closure.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *add(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uintptr_t *num = (uintptr_t *)context;</div>
<div class="line">    uintptr_t other = (uintptr_t)params;</div>
<div class="line">    *num += other;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uintptr_t value = 0;</div>
<div class="line">uel_closure_t closure = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;add, (<span class="keywordtype">void</span> *)&amp;value);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="event-loop_8h.html#a1d3464894f0281c7b1f4c9c18dddcaf4">uel_evloop_enqueue_closure</a>(&amp;loop, &amp;closure, (<span class="keywordtype">void</span> *)1);</div>
<div class="line"><span class="comment">// value is 0</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="event-loop_8h.html#ad5371df9faa7072e1fd11470448de901">uel_evloop_run</a>(&amp;loop);  </div>
<div class="line"><span class="comment">// value is 1</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="event-loop_8h.html#a1d3464894f0281c7b1f4c9c18dddcaf4">uel_evloop_enqueue_closure</a>(&amp;loop, &amp;closure, (<span class="keywordtype">void</span> *)2);</div>
<div class="line"><a class="code" href="event-loop_8h.html#a1d3464894f0281c7b1f4c9c18dddcaf4">uel_evloop_enqueue_closure</a>(&amp;loop, &amp;closure, (<span class="keywordtype">void</span> *)3);</div>
<div class="line"><a class="code" href="event-loop_8h.html#ad5371df9faa7072e1fd11470448de901">uel_evloop_run</a>(&amp;loop);</div>
<div class="line"><span class="comment">// value is 6</span></div>
</div><!-- fragment --><p><em><b>WARNING!</b></em> <code>uel_evloop_run</code> is the single most important function within µEvLoop. Almost every other core component depends on the event loop and if this function is not called, the loop won't work at all. Don't ever let it starve.</p>
<h3>Observers</h3>
<p>The event loop can be instructed to observe some arbitrary volatile value and react to changes in it.</p>
<p>Because observers are completely passive, they are ideal for triggering side-effects from ISRs without <b>any</b> latency. However, each observer set does incur extra latency during runloops, as the observed value must be continuously polled.</p>
<p>```c static volatile uintptr_t adc_reading = 0;</p>
<p>void my_adc_isr(){ adc_reading = my_adc_buffer; my_adc_isr_flag = 0; }</p>
<p>static void *process_adc_reading(void *context, void *params){ uintptr_t value = (uintptr_t)params; // Do something with <code>value</code></p>
<p>return NULL; } uel_closure_t processor = uel_closure_create(process_adc_reading, NULL);</p>
<p>// This ensures each runloop the <code>adc_reading</code> variable is polled and, in case // of changes to it, the <code>processor</code> closure is called with its new value as // parameter. uel_event_t *observer = uel_evloop_observe(&amp;loop, &amp;adc_reading, &amp;processor);</p>
<p>// When an observer isn't needed anymore, it can be disposed of to release any // used system resources. // <b>DON'T</b> use an observer after it has been cancelled. uel_event_observer_cancel(observer). </p><div class="fragment"><div class="line">### Signal</div>
<div class="line"> </div>
<div class="line">Signals are similar to events in Javascript. It allows the programmer to message distant parts of the system to communicate with each other in a pub/sub fashion.</div>
<div class="line"> </div>
<div class="line">At the centre of the signal `system` is the Signal Relay, a structure that bind specific signals to its listeners. When a signal is emitted, the relay will **asynchronously** run each listener registered for that signal. If the listener was not recurring, it will be destroyed upon execution by the event loop.</div>
<div class="line"> </div>
<div class="line">#### Signals and relay initialisation</div>
<div class="line"> </div>
<div class="line">To use signals, the programmer must first define what signals will be available in a particular relay, then create the relay bound to this signals.</div>
<div class="line"> </div>
<div class="line">To be initialised, the relay must have access to the system&#39;s internal pools and queues. The programmer will also need to supply it a buffer of [linked lists](#linked-lists), where listeners will be stored.</div>
<div class="line"> </div>
<div class="line"> ```c</div>
<div class="line">#include &lt;uevloop/system/containers/system-pools.h&gt;</div>
<div class="line">#include &lt;uevloop/system/containers/system-queues.h&gt;</div>
<div class="line">#include &lt;uevloop/system/signal.h&gt;</div>
<div class="line">#include &lt;uevloop/utils/linked-list.h&gt;</div>
<div class="line"> </div>
<div class="line">// Create the system containers</div>
<div class="line">uel_syspools_t pools;</div>
<div class="line">uel_syspools_init(&amp;pools);</div>
<div class="line">uel_sysqueues_t queues;</div>
<div class="line">uel_sysqueues_init(&amp;queues);</div>
<div class="line"> </div>
<div class="line">// Define what signals will be available to this relay.</div>
<div class="line">// Doing so in an enum makes it easy to add new signals in the future.</div>
<div class="line">enum my_component_signals {</div>
<div class="line">    SIGNAL_1 = 0,</div>
<div class="line">    SIGNAL_2,</div>
<div class="line">    // New events would go here</div>
<div class="line">    SIGNAL_COUNT</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Declare the relay buffer. Note this array will be the number of signals large.</div>
<div class="line">uel_llist_t buffer[SIGNAL_COUNT];</div>
<div class="line"> </div>
<div class="line">// Create the relay</div>
<div class="line">uel_signal_relay_t relay;</div>
<div class="line">uel_signal_relay_init(&amp;relay, &amp;pools, &amp;queues, buffer, SIGNAL_COUNT);</div>
</div><!-- fragment --><h3>Signal operation</h3>
<div class="fragment"><div class="line"><span class="comment">// This is the listener function.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *respond_to_signal(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">  uintptr_t num = (uintptr_t)context;</div>
<div class="line">  <span class="comment">// Signals can be emitted with parameters, just like events in JS</span></div>
<div class="line">  <span class="keywordtype">char</span> c = (char)(uintptr_t)params;</div>
<div class="line">  printf(<span class="stringliteral">&quot;%d%c\n&quot;</span>, num, c);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Listeners can be persistent. They will fire once each time the signal is emitted</span></div>
<div class="line">uel_closure_t respond_to_signal_1 = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;respond_to_signal, (<span class="keywordtype">void</span> *)1);</div>
<div class="line"><a class="code" href="signal_8h.html#acf4ce9806bae5489706f0409f0a58067">uel_signal_listener_t</a> listener_1 = <a class="code" href="signal_8h.html#ac11a6acd9237d30551bc0dc8ba406189">uel_signal_listen</a>(SIGNAL_1, &amp;relay, &amp;respond_to_signal_1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Listeners can also be transient, so they fire ust on first emission</span></div>
<div class="line">uel_closure_t respond_to_signal_2 = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(&amp;respond_to_signal, (<span class="keywordtype">void</span> *)2);</div>
<div class="line"><a class="code" href="signal_8h.html#acf4ce9806bae5489706f0409f0a58067">uel_signal_listener_t</a> listener_2 = <a class="code" href="signal_8h.html#a6d59d4a7b4c0c5f6b1d271ed6e8a8212">uel_signal_listen_once</a>(SIGNAL_2, &amp;relay, &amp;respond_to_signal_2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="signal_8h.html#af849f4effe2577efe439387d3a8a710a">uel_signal_emit</a>(SIGNAL_1, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;a&#39;</span>)); <span class="comment">// prints 1a</span></div>
<div class="line"><a class="code" href="signal_8h.html#af849f4effe2577efe439387d3a8a710a">uel_signal_emit</a>(SIGNAL_2, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;b&#39;</span>)); <span class="comment">// prints 2b</span></div>
<div class="line"><a class="code" href="signal_8h.html#af849f4effe2577efe439387d3a8a710a">uel_signal_emit</a>(SIGNAL_1, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;c&#39;</span>)); <span class="comment">// prints 1c</span></div>
<div class="line"><a class="code" href="signal_8h.html#af849f4effe2577efe439387d3a8a710a">uel_signal_emit</a>(SIGNAL_2, &amp;relay, (<span class="keywordtype">void</span> *)(<span class="charliteral">&#39;d&#39;</span>)); <span class="comment">// doesn&#39;t print anything</span></div>
</div><!-- fragment --><p>Please note the listener function will not be executed immediately, despite what this last snippet can lead to believe. Internally, each closure will be sent to the event loop and only when it runs will the closures be invoked.</p>
<p>You can also unlisten for events. This will prevent the listener returned by a <code><a class="el" href="signal_8h.html#ac11a6acd9237d30551bc0dc8ba406189" title="Attaches a listener closure to some signal at a particular relay.">uel_signal_listen()</a></code> or <code><a class="el" href="signal_8h.html#a6d59d4a7b4c0c5f6b1d271ed6e8a8212" title="Attaches a listener closure to some signal at a particular relay. The listener closure will be invoke...">uel_signal_listen_once()</a></code> operation to have its closure invoked when the <a href="#event-loop">event loop</a> performs the next runloop. Additionally, said listener will be removed from the signal vector on such opportunity.</p>
<div class="fragment"><div class="line"><a class="code" href="signal_8h.html#a3fb31014f6cec7acf29e7de4b66fe531">uel_signal_unlisten</a>(listener_1, &amp;relay);</div>
<div class="line"><a class="code" href="signal_8h.html#a3fb31014f6cec7acf29e7de4b66fe531">uel_signal_unlisten</a>(listener_2, &amp;relay);  <span class="comment">// This has no effect because the listener</span></div>
<div class="line">                                          <span class="comment">// for SIGNAL_2 has already been marked as unlistened</span></div>
</div><!-- fragment --><h1>Appendix A: Promises</h1>
<p>Promises are data structures that bind an asynchronous operation to the possible execution paths that derive from its result. They are heavily inspired by Javascript promises.</p>
<p>Promises allow for very clean asynchronous code and exceptional error handling.</p>
<h2>Promise stores</h2>
<p>All promises must be created at a store, to where they will come back once destroyed. A promise store encapsulates object pools for promises and segments, the two composing pieces for promise operation.</p>
<h3>Promise store creation</h3>
<p>Promise store need access to two object pools, one for promises and one for segments. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;uevloop/utils/object-pools.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;uevloop/system/promise.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PROMISE_STORE_SIZE_LOG2N    4   // 16 promises</span></div>
<div class="line"><span class="preprocessor">#define SEGMENT_STORE_SIZE_LOG2N    6   // 64 segments</span></div>
<div class="line"> </div>
<div class="line">uel_objpool_t promise_pool;</div>
<div class="line">uel_objpool_t segment_pool;</div>
<div class="line"><a class="code" href="object-pool_8h.html#a6f94946d39d323f7ea0f409962c59f1e">UEL_DECLARE_OBJPOOL_BUFFERS</a>(uel_promise_t, PROMISE_STORE_SIZE_LOG2N, promise);</div>
<div class="line"><a class="code" href="object-pool_8h.html#a6f94946d39d323f7ea0f409962c59f1e">UEL_DECLARE_OBJPOOL_BUFFERS</a>(uel_promise_segment_t, SEGMENT_STORE_SIZE_LOG2N, segment);</div>
<div class="line"><a class="code" href="object-pool_8h.html#ab49dd047b6e4fcc0939dfd651e3b3666">uel_objpool_init</a>(</div>
<div class="line">    &amp;promise_pool,</div>
<div class="line">    PROMISE_STORE_SIZE_LOG2N,</div>
<div class="line">    <span class="keyword">sizeof</span>(uel_promise_t),</div>
<div class="line">    <a class="code" href="object-pool_8h.html#a623ea70a0df4cc76d0e65a99bc5c26c9">UEL_OBJPOOL_BUFFERS</a>(promise)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="object-pool_8h.html#ab49dd047b6e4fcc0939dfd651e3b3666">uel_objpool_init</a>(</div>
<div class="line">    &amp;segment_pool,</div>
<div class="line">    SEGMENT_STORE_SIZE_LOG2N,</div>
<div class="line">    <span class="keyword">sizeof</span>(uel_promise_segment_t),</div>
<div class="line">    <a class="code" href="object-pool_8h.html#a623ea70a0df4cc76d0e65a99bc5c26c9">UEL_OBJPOOL_BUFFERS</a>(segment)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">uel_promise_store_t store = <a class="code" href="promise_8h.html#a4e3a7f9f0d154d4a2fa1c17520bd5561">uel_promise_store_create</a>(&amp;promise_pool, &amp;segment_pool);</div>
</div><!-- fragment --><h2>Promises and segments</h2>
<p>As mentioned above, promises and segments are the two building blocks for composing asynchronous chains of events. Promises represent the asynchronous operation <em>per se</em> and segments are the synchronous processing that occurs when a promise settles.</p>
<p>Settling a promise means transitioning it into either <b>resolved</b> or <b>rejected</b> states which respectively indicate success or error of the asynchronous operation, optionally assigning a meaningful value to the promise.</p>
<h3>Promise creation</h3>
<p>There are two necessary pieces for creating a promise: a store and a constructor closure that starts the asynchronous operation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *start_some_async(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">return</span> NULL; <span class="comment">// return value is ignored</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uel_promise_t *promise =</div>
<div class="line">    <a class="code" href="promise_8h.html#a5c0cdf2e971bf738362af1761c729bd4">uel_promise_create</a>(&amp;store, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(start_some_async, NULL));</div>
</div><!-- fragment --><p>When the promise is created, <code>start_some_async</code> is invoked immediately, taking the promise pointer as parameter.</p>
<p>On creation, promises are in the <b>pending</b> state. This means its asynchronous operation has not been completed yet and the promise does not hold any meaningful value.</p>
<h3>Promise settling</h3>
<p>Once the operation is completed (and this can also be synchronously done from inside the constructor closure), there are two functions for signalling either success or failure of the asynchronous operation:</p>
<div class="fragment"><div class="line"><a class="code" href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a>(promise1, (<span class="keywordtype">void</span> *)SOME_VALUE); <span class="comment">// operation succeeded</span></div>
<div class="line"><a class="code" href="promise_8h.html#a2e904cfb182cb5619b0a31790fca697e">uel_promise_reject</a>(promise2, (<span class="keywordtype">void</span> *)SOME_ERROR);  <span class="comment">// operation failed</span></div>
</div><!-- fragment --><p>Once a promise is settled, it holds a value that can be accessed via <code>promise-&gt;value</code>.</p>
<h3>Segments</h3>
<p>Segments represent the synchronous phase that follows a promise settling. They contain two closures, one for handling resolved promises and one for handling rejected promises. Either one is chosen at runtime, depending on the settled state of the promise, and is invoked with the promise as parameter.</p>
<p>Depending on the promise state, attaching segments have different effects. When a promise is pending, attached segments just get enqueued for execution once the promise is settled. Should the promise be already settled, attached segments get processed immediately instead.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stddef.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *report_success(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keywordtype">char</span> *tag = (<span class="keywordtype">char</span> *)context;</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;promise %s resolved with %d\n&quot;</span>, tag, promise-&gt;value);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *report_error(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keywordtype">char</span> *tag = (<span class="keywordtype">char</span> *)context;</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;promise %s rejected with %d\n&quot;</span>, tag, promise-&gt;value);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume p1, p2 and p3 as pending, resolved and rejected promises, respectively</span></div>
<div class="line"><span class="comment">// p2 is resolved with (uintptr_t)10 and p3 is rejected with (uintptr_t)100</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="promise_8h.html#a4b1b8ee1101104f1beaa782ef630767f">uel_promise_after</a>(</div>
<div class="line">    p1,</div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_success, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;p1&quot;</span>),</div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_error, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;p1&quot;</span>)</div>
<div class="line">);</div>
<div class="line"><span class="comment">// Neither closure gets invoked. Instead, a new segment containing them is enqueued.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="promise_8h.html#a4b1b8ee1101104f1beaa782ef630767f">uel_promise_after</a>(</div>
<div class="line">    p2,</div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_success, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;p2&quot;</span>),  </div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_error, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;p2&quot;</span>)</div>
<div class="line">);</div>
<div class="line"><span class="comment">// As the promise is already resolved, instead of enqueueing a segment, the first</span></div>
<div class="line"><span class="comment">// closure is invoked.</span></div>
<div class="line"><span class="comment">// &quot;p2 resolved with 10&quot; is printed</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="promise_8h.html#a4b1b8ee1101104f1beaa782ef630767f">uel_promise_after</a>(</div>
<div class="line">    p3,</div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_success, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;p3&quot;</span>),  </div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_error, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;p3&quot;</span>)</div>
<div class="line">);</div>
<div class="line"><span class="comment">// Similarly, as the promise is already rejected, the second closure gets invoked</span></div>
<div class="line"><span class="comment">// immediately.</span></div>
<div class="line"><span class="comment">// &quot;p3 rejected with 100&quot; is printed</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a>(p1, (uintptr_t)1);</div>
<div class="line"><span class="comment">// Upon settling, segments are removed from the queue and processed.</span></div>
<div class="line"><span class="comment">// &quot;p1 resolved with 1&quot; is printed</span></div>
</div><!-- fragment --><p>The <code><a class="el" href="promise_8h.html#a4b1b8ee1101104f1beaa782ef630767f" title="Adds a new synchronous segment to the promise. Either of its closures will be invoked,...">uel_promise_after()</a></code> function takes two closures as parameters. This is useful for splitting the execution path in two mutually exclusive routes depending on the settled state of the promise.</p>
<p>There are three other functions for enqueuing segments. They can be used for attaching segments that only produce effects on specific settled states or attaching the same closure to both states:</p>
<div class="fragment"><div class="line"><a class="code" href="promise_8h.html#abb34042cccffccafefb813a902ec8389">uel_promise_then</a>(my_promise, my_closure);</div>
<div class="line"><span class="comment">// `my_closure` is invoked only when `my_promise` is resolved.</span></div>
<div class="line"><span class="comment">// The added segment is ignored if the promise is rejected.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="promise_8h.html#a550561c65f5abb38bc5c3b25083dd468">uel_promise_catch</a>(my_promise, my_closure);</div>
<div class="line"><span class="comment">// `my_closure` is invoked only when `my_promise` is rejected.</span></div>
<div class="line"><span class="comment">// The added segment is ignored if the promise is resolved.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="promise_8h.html#a6a932817fcd43d5eaa2723b8c34132ff">uel_promise_always</a>(my_promise, my_closure);</div>
<div class="line"><span class="comment">// `my_closure` is invoked always upon settling, regardless of the settled state</span></div>
</div><!-- fragment --><h3>Segment chains and promise resettling</h3>
<p>Any number of segments can be attached to some promise. They will be either processed immediately, in case the promise is already settled, or enqueued for processing upon settling in the future. Regardless, attached segments are always processed in registration order.</p>
<p>Chaining segments is useful because segments have the ability to commute between execution paths through <em>promise resettling</em>. To resettle a promise means changing its state and value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *store_char(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *var = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)context;</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    <span class="keywordflow">if</span>((uintptr_t)promise-&gt;value &lt;= 255) {</div>
<div class="line">        *var = (<span class="keywordtype">unsigned</span> char)(uintptr_t)promise-&gt;value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <a class="code" href="promise_8h.html#a2d226c4ed1a94964db50dbb5a7f958df">uel_promise_resettle</a>(promise, <a class="code" href="promise_8h.html#ac0201d84b1e362087d83bdb57a8e8856ae137a12a3c564815d59e2548e304ab39">UEL_PROMISE_REJECTED</a>, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;Value too big&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *report_error(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;promise was rejected with error &#39;%s&#39;\n&quot;</span>, (<span class="keywordtype">char</span> *)promise-&gt;value);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *done(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">char</span> *states[3] = { <span class="stringliteral">&quot;pending&quot;</span>, <span class="stringliteral">&quot;resolved&quot;</span>, <span class="stringliteral">&quot;rejected&quot;</span> };</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;operation done with state &#39;%s&#39;\n&quot;</span>, states[promise-&gt;state]);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c1 = 0;</div>
<div class="line">uel_promise_t *p1 = <a class="code" href="promise_8h.html#a5c0cdf2e971bf738362af1761c729bd4">uel_promise_create</a>(&amp;store, <a class="code" href="closure_8h.html#a1f88fc773dbcea710594c7175d3a4ac3">uel_nop</a>()); <span class="comment">// Creates a pending promise</span></div>
<div class="line"><a class="code" href="promise_8h.html#abb34042cccffccafefb813a902ec8389">uel_promise_then</a>(p1, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(store_char, (<span class="keywordtype">void</span> *)&amp;c1));</div>
<div class="line"><a class="code" href="promise_8h.html#a550561c65f5abb38bc5c3b25083dd468">uel_promise_catch</a>(p1, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(report_error, NULL));</div>
<div class="line">uel_promsie_always(p1, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(done, NULL));</div>
</div><!-- fragment --><p>This builds a segment chain attached to promise <code>p1</code>. Each segment added describes one synchronous step to be executed for each of the two settled states.</p>
<p>Segments are processed sequentially, from first to last, starting with the closure relative to the state the promise was settled as. The following table illustrates this chain:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">State </th><th class="markdownTableHeadCenter">Segment 1 </th><th class="markdownTableHeadCenter">Segment 2 </th><th class="markdownTableHeadCenter">Segment 3  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">resolved </td><td class="markdownTableBodyCenter">store_char </td><td class="markdownTableBodyCenter">nop </td><td class="markdownTableBodyCenter">done  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">rejected </td><td class="markdownTableBodyCenter">nop </td><td class="markdownTableBodyCenter">report_error </td><td class="markdownTableBodyCenter">done  </td></tr>
</table>
<p>The outcome of this chain is determined upon settling. For example, given the following resolution:</p>
<div class="fragment"><div class="line"><a class="code" href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a>(p1, (<span class="keywordtype">void</span> *)10);</div>
</div><!-- fragment --><p>The first closure invoked is <code>store_char</code>, in segment 1. In the closure function, the test condition <code>promise-&gt;value &lt;= 255</code> is true, so the closure proceeds to store its value in the <code>c1</code> variable.</p>
<p>As the promise remains resolved, it advances to segment 2, where it finds a <code>nop</code> (no-operation). This is due to the segment being attached via <code>uel_promise_catch</code>.</p>
<p>The promise then advances to segment 3, where it finds the <code>done</code> closure. The process then ends and the promise retains its state and value (<code>UEL_PROMISE_RESOLVED</code> and <code>(void *)10</code> in this case). By then, <code>c1</code> holds <code>(char)10</code> and &lsquo;operation done with state 'resolved&rsquo;` is printed.</p>
<p>If instead the promise was resolved as: </p><div class="fragment"><div class="line"><a class="code" href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a>(p1, (<span class="keywordtype">void</span> *)1000);</div>
</div><!-- fragment --><p>Then the test condition <code>promise-&gt;value &lt;= 255</code> would have failed. The <code>store_char</code> would then skip storing the value and would rather <em>resettle</em> the promise as rejected, with some error message as value. This effectively commutes the execution path to the <em>rejected</em> branch.</p>
<p>Once the <code>store_char</code> returns, as the promise is now rejected, the <code>report_error</code> closure is invoked and &lsquo;promise was rejected with error 'Value too big&rsquo;<code>is printed. The</code>done<code>closure is then invoked and prints</code>operation done with state 'rejected'`.</p>
<p>Similarly, if instead the promise had been rejected as: </p><div class="fragment"><div class="line"><a class="code" href="promise_8h.html#a2e904cfb182cb5619b0a31790fca697e">uel_promise_reject</a>(p1, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;Asynchronous operation failed&quot;</span>);</div>
</div><!-- fragment --><p>Segment 1 would be ignored, <code>report_error</code> would be invoked and print &lsquo;promise was rejected with error 'Asynchronous operation failed&rsquo;<code>and, at segment 3,</code>done<code>would be invoked and print</code>operation done with state 'rejected'`.</p>
<p>Resettling can also be used for recovering from errors if it commutes back to <code>resolved</code> state. This constitutes an excellent exception system that allows errors raised in loose asynchronous operations to be rescued consistently. Even exclusively synchronous processes can benefit from this error rescuing system.</p>
<p>As a last note, segments can also resettle a promise as <code>UEL_PROMISE_PENDING</code>. This halts the synchronous stage immediately, leaving any unprocessed segments in place. This phase can be restarted by either resolving or rejecting the promise again.</p>
<h3>Nested promises</h3>
<p>Promises can be nested into each other, allowing for complex asynchronous operations to compose a single segment chain. This provides superb flow control for related asynchronous operations that would otherwise produce a lot of spaghetti code.</p>
<p>Whenever a promise segment returns any non-null value, it is cast to a promise pointer. The original promise then transitions back to <code>pending</code> state and awaits for the returned promise to settle. Once this new promise is settled, the original promise is resumed with whatever state and value the new promise was settled as.</p>
<p>For instance, suppose the programmer is programming an MCU that possesses an ADC with an arbitrarily long buffer and a DMA channel. The program must start the ADC, which will sample <code>N</code> times and store it in its buffer. After <code>N</code> samples have been taken, the DMA channel must be instructed to move it out of the ADC buffer into some memory-mapped buffer, where it will be processed.</p>
<p>This could be easily accomplished with signals or callbacks, but would eventually lead to confusing and discontinuous code. With nested promises, however, it is easy to describe the whole process into one single chain.</p>
<p>Suppose this is the implementation for the DMA and ADC modules:</p>
<div class="fragment"><div class="line"><span class="comment">// ADC implementation</span></div>
<div class="line"><span class="keyword">static</span> uel_promise_t *adc_promise;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This ISR is called when the ADC finishes sampling</span></div>
<div class="line"><span class="comment">// the instructed number of samples</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> adc_isr() {</div>
<div class="line">    <a class="code" href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a>(adc_promise, (<span class="keywordtype">void</span> *)ADC_BUFFER);</div>
<div class="line">    adc_promise = NULL;</div>
<div class="line">    adc_isr_flag = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Launches the ADC and returns. This effectively starts an asynchronous operation.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *start_adc(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    uintptr_t count = (uintptr_t)context;</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    ADC_COUNT = count;</div>
<div class="line">    ADC_START = 1;</div>
<div class="line">    adc_promise = promise;</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Public interface function. Returns a promise that,</span></div>
<div class="line"><span class="comment">// when resolved, will contain the address of the buffer where</span></div>
<div class="line"><span class="comment">// data was sampled</span></div>
<div class="line">uel_promise_t *adc_read(uintptr_t count) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="promise_8h.html#a5c0cdf2e971bf738362af1761c729bd4">uel_promise_create</a>(&amp;store, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(start_adc, (<span class="keywordtype">void</span> *)count));</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// DMA implementation</span></div>
<div class="line"><span class="keyword">static</span> uel_promise_ t *dma_promise;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This ISR is called when the DMA channel has finished</span></div>
<div class="line"><span class="comment">// moving data</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> dma_isr() {</div>
<div class="line">    <a class="code" href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a>(dma_promise, (<span class="keywordtype">void</span> *)DMA_DESTINATION);</div>
<div class="line">    dma_promise = NULL;</div>
<div class="line">    dma_isr_flag = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Auxiliary structure to hold DMA mapping information</span></div>
<div class="line"><span class="keyword">struct </span>dma_mapping {</div>
<div class="line">    <span class="keywordtype">void</span> *source;</div>
<div class="line">    <span class="keywordtype">void</span> *destination;</div>
<div class="line">    uintptr_t count;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Launches the DMA channel, starting an asynchronous operation</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *start_dma(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keyword">struct </span>dma_mapping *mapping = (<span class="keyword">struct </span>dma_mapping *)context;</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    DMA_SOURCE = mapping-&gt;source;</div>
<div class="line">    DMA_DESTINATION = mapping-&gt;destination;</div>
<div class="line">    DMA_COUNT = mapping-&gt;count;</div>
<div class="line">    DMA_START = 1;</div>
<div class="line">    adc_promise = promise;</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Public interface function.</span></div>
<div class="line"><span class="comment">// Returns a promise that, when resolved, will hold the address</span></div>
<div class="line"><span class="comment">// of the buffer to where data was moved</span></div>
<div class="line">uel_promise_t *dma_move(<span class="keywordtype">void</span> *destination, <span class="keywordtype">void</span> *source, uintptr_t count) {</div>
<div class="line">    <span class="keyword">struct </span>dma_mapping mapping = { source, destination, count };</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="promise_8h.html#a5c0cdf2e971bf738362af1761c729bd4">uel_promise_create</a>(&amp;store, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(start_adc, (<span class="keywordtype">void</span> *)&amp;mapping));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Implementing the project requirements is this simple:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define N  10 // Will take 10 samples</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *move_from_buffer(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    <span class="keywordtype">void</span> *source = promise-&gt;value;</div>
<div class="line">    <span class="keywordtype">void</span> *destination = context;</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)dma_move(destination, source, N);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *data_moved(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    uel_promise_t *promise = (uel_promise_t *)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Data moved to %p\n&quot;</span>, promise-&gt;value);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">uel_promise_t *promise = adc_read(N);</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> destination[N];</div>
<div class="line"><a class="code" href="promise_8h.html#abb34042cccffccafefb813a902ec8389">uel_promise_then</a>(promise, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(move_from_buffer, (<span class="keywordtype">void</span> *)destination));</div>
<div class="line"><a class="code" href="promise_8h.html#abb34042cccffccafefb813a902ec8389">uel_promise_then</a>(promise, <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(data_moved, NULL));</div>
</div><!-- fragment --><p>Note that, in the above example, promises are resolved <b>synchronously</b> inside the ISR's. This may be not desirable due to performance reasons, but can be easily improved by enqueueing a closure that resolves nested promises into the <a href="#event-loop">event loop</a>.</p>
<h3>Promise destruction and promise helpers</h3>
<p>To destroy a promise, call <code><a class="el" href="promise_8h.html#ac43ce3e3316581da32cf3e21c15901f0" title="Destroys a promise and all of its segments. Settling this promise afterwards yields undefined behavio...">uel_promise_destroy()</a></code>. This will release all segments and then the promise itself. Settling a promise after it has been destroyed is undefined behaviour.</p>
<p>Because settling and destroying promises are so frequent, there are helper functions that emit closures that automate this work:</p>
<div class="fragment"><div class="line"><span class="comment">// When invoked, destroys the promise</span></div>
<div class="line">uel_closure_t destroyer = <a class="code" href="promise_8h.html#a9b68547bf7ac1a5860b165a4638bcc51">uel_promise_destroyer</a>(promise);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When invoked with some value, resolves the promise with that value</span></div>
<div class="line">uel_closure_t resolver = <a class="code" href="promise_8h.html#acffa84389150a36442905a6f89cb827b">uel_promise_resolver</a>(promise);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When invoked with some value, rejects the promise with that value</span></div>
<div class="line">uel_closure_t rejecter = <a class="code" href="promise_8h.html#a09b820cf5093f6979da34cbe6faa1787">uel_promise_rejecter</a>(promise);</div>
</div><!-- fragment --><h1>Appendix B: Modules</h1>
<p>Modules are independent units of behaviour, self-contained and self-allocated, with clear lifecycle hooks, interface and dependencies. They enforce separation of concerns and isolation by making clear how your code interacts with the rest of the application.</p>
<p>Modules are absolutely optional and very thin on the library side. They are basically a convention of how to write code in a fashion that works well with µEvLoop.</p>
<p>Modules can serve as a variety of purposes:</p><ul>
<li>They can act as bridges to static data, such as SFRs;</li>
<li>They can be object factories, meant to distribute and recycle objects to other modules;</li>
<li>They can act as services, background processes that interact with other parts of the application in a sattelite-fashion.</li>
</ul>
<h2>Module creation</h2>
<div class="fragment"><div class="line"><span class="comment">// File: my_module.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="module_8h.html">uevloop/utils/module.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="application_8h.html">uevloop/system/containers/application.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>my_module my_module_t; <span class="comment">// Private implementation</span></div>
<div class="line"> </div>
<div class="line">uel_module_t *my_module(uel_application_t *my_app);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Any functions&#39; signatures to operate the module go here</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// File: my_module.c</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;my_module.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_module {</div>
<div class="line">    uel_module_t base; <span class="comment">// Inherits base interface</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Other properties</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The config hook is used to prepare the module.</span></div>
<div class="line"><span class="comment">// When it is fired by the `application`, all modules are guaranteed to be</span></div>
<div class="line"><span class="comment">// registered, but may still be in an inconsistent state.</span></div>
<div class="line"><span class="comment">// Modules are loaded in the order they are supplied, so previous modules will</span></div>
<div class="line"><span class="comment">// already be configured.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> config(uel_module_t *mod){</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The launch hook is where the module should effectively start its functions.</span></div>
<div class="line"><span class="comment">// All modules here are guaranteed to be registered and properly configurated.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> launch(uel_module_t *mod){</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The constructor function is the only mandatory symbol to be exported.</span></div>
<div class="line"><span class="comment">// This function should initialise all independent or readly available data.</span></div>
<div class="line"><span class="comment">// It must not be called more than once per module.</span></div>
<div class="line">uel_module_t *my_module(uel_application_t *my_app){</div>
<div class="line">    <span class="keyword">static</span> my_module_t module;</div>
<div class="line">    <a class="code" href="module_8h.html#a3a1d7dc04cf2b7c5c84a61cfd5056772">uel_module_init</a>(&amp;module.base, config, launch, my_app);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialise other module&#39;s properties</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> &amp;module.base;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Module registration</h2>
<p>Modules are operated by the <code>application</code> component. It is responsible for loading, configuring and launching each module.</p>
<div class="fragment"><div class="line"><span class="comment">// File: my_app_modules.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;my_module.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Each module must be identified by a positive integer, zero-indexed.</span></div>
<div class="line"><span class="comment">// Storing module IDs in an enum makes it easy to add new modules in the future.</span></div>
<div class="line"><span class="keyword">enum</span> MY_APP_MODULES {</div>
<div class="line">    MY_MODULE,</div>
<div class="line">    <span class="comment">// other modules...,</span></div>
<div class="line">    MY_APP_MODULE_COUNT</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// File: main.c</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="application_8h.html">uevloop/system/containers/application.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;my_app_modules.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates the controlling application</span></div>
<div class="line">uel_application_t my_app;</div>
<div class="line"><a class="code" href="application_8h.html#ab221d8fc71af4fbf92525a7691b039ae">uel_app_init</a>(&amp;my_app);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declares a list of module pointers to be supplied to the application.</span></div>
<div class="line">uel_module_t *modules[MY_APP_MODULE_COUNT];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Individually initialising pointers in the list ensures IDs always</span></div>
<div class="line"><span class="comment">// match their corresponding module, even if they change during development.</span></div>
<div class="line">modules[MY_MODULE] = my_module(&amp;my_app);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This loads the modules into the application:</span></div>
<div class="line"><span class="comment">// - The module list is stored as the application registry;</span></div>
<div class="line"><span class="comment">// - Each module&#39;s configuration hook is sequentially invoked, according to</span></div>
<div class="line"><span class="comment">//   their position in the registry;</span></div>
<div class="line"><span class="comment">// - Each module&#39;s launch hook is sequentially invoked, equally ordered by</span></div>
<div class="line"><span class="comment">//   the registry.</span></div>
<div class="line"><a class="code" href="application_8h.html#aed8a446de669fcab5bc591fb28d3b5f6">uel_app_load</a>(&amp;my_app, modules, MY_APP_MODULE_COUNT);</div>
</div><!-- fragment --><h2>Dependency Injection</h2>
<p>There are two method for injecting a registered module: <em>parametrised injection</em> and <em>ad-hoc injection</em>. Each is adequate for a different situation:</p>
<h3>Parametrised injection</h3>
<p>Parametrised dependencies are dependencies that are supplied during module construction.</p>
<p>Given the following module header: </p><div class="fragment"><div class="line"><span class="comment">// File: my_greeter.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;my_module.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="module_8h.html">uevloop/utils/module.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="application_8h.html">uevloop/system/containers/application.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>my_greeter my_greeter_t;</div>
<div class="line">uel_module_t *my_greeter(</div>
<div class="line">    uel_application_t *my_app,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *name,         <span class="comment">// &lt;-- Parametrised dependency</span></div>
<div class="line">    my_module_t *other_module <span class="comment">// &lt;-- Dependencies can be other modules</span></div>
<div class="line">);</div>
</div><!-- fragment --><p>The application loading procedure would be: </p><div class="fragment"><div class="line"><span class="comment">// File: my_app_modules.h</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span> MY_APP_MODULES {</div>
<div class="line">    MY_MODULE,</div>
<div class="line">    MY_GREETER,</div>
<div class="line">    MY_APP_MODULE_COUNT</div>
<div class="line">};</div>
</div><!-- fragment --><p>```c // File: main.c</p>
<p>uel_module_t *modules[MY_APP_MODULE_COUNT];</p>
<p>modules[MY_MODULE] = my_module(&amp;my_app);</p>
<p>// Injects parametrised dependencies <code>name</code> and <code>other_module</code> modules[MY_GREETER] = my_greeter(&amp;my_app, "King Kong", (my_module_t *)modules[MY_MODULE]);</p>
<p>uel_app_load(&amp;my_app, modules, MY_APP_MODULE_COUNT) </p><div class="fragment"><div class="line">Parametrised injection facilitates reasoning about what each module depends on and in which order they are loaded. This is the preferable way to inject dependencies into modules.</div>
<div class="line"> </div>
<div class="line">#### Ad-hoc injection</div>
<div class="line">Ad-hoc injections can occur anywhere, including places outside the scope of the application&#39;s managed modules.</div>
<div class="line"> </div>
<div class="line">```c</div>
<div class="line">// ANYWHERE with access to `my_app`:</div>
<div class="line"> </div>
<div class="line">#include &lt;uevloop/system/containers/application.h&gt;</div>
<div class="line">#include &quot;my_greeter.h&quot;</div>
<div class="line">#include &quot;my_app_modules.h&quot;</div>
<div class="line"> </div>
<div class="line">my_greeter_t *greeter = (my_greeter_t *)uel_app_require(&amp;my_app, MY_GREETER);</div>
</div><!-- fragment --><p>While Ad-hoc injections seem easier, they make more difficult to know on which modules some particular piece of code depends on. Also, because they require the modules to already be loaded into the registry, they cannot be used during the configuration phase.</p>
<h1>Appendix C: Useful goodies</h1>
<h2>Iterators</h2>
<p>Iterators are abstractions on arbitrary collections of items. They provide a uniform interface for yielding each element in the iterated collection, disregarding implementation details of such collection.</p>
<p>There are two iterator specialisations shipped with µEvLoop:</p>
<h3>Array iterators</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8h.html">uevloop/utils/iterator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#define NUMS_LENGTH 5</span></div>
<div class="line"> </div>
<div class="line">uintptr_t nums[NUMS_LENGTH] = { 1, 2, 3, 4, 5 };</div>
<div class="line">uel_iterator_array_t array_iterator =</div>
<div class="line">        <a class="code" href="iterator_8h.html#a0acc2751d0a555963f923fca73c0200a">uel_iterator_array_create</a>(nums, NUMS_LENGTH, <span class="keyword">sizeof</span>(uintptr_t));</div>
</div><!-- fragment --><h3>Linked list iterators</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8h.html">uevloop/utils/iterator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linked-list_8h.html">uevloop/utils/linked-list.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">uel_llist_node_t nodes[] = {</div>
<div class="line">    { (<span class="keywordtype">void</span> *)1, NULL },</div>
<div class="line">    { (<span class="keywordtype">void</span> *)2, NULL ),</div>
<div class="line">    { (<span class="keywordtype">void</span> *)3, NULL }</div>
<div class="line">};</div>
<div class="line">uel_llist_t list;</div>
<div class="line"><a class="code" href="linked-list_8h.html#a636d9d433df7fd53fc3138b6c77df75a">uel_llist_init</a>(&amp;list);</div>
<div class="line"><a class="code" href="linked-list_8h.html#a0a98f53f55f86adb45e4f0f357d748a8">uel_llist_push_head</a>(&amp;list, &amp;nodes[0]);</div>
<div class="line"><a class="code" href="linked-list_8h.html#a0a98f53f55f86adb45e4f0f357d748a8">uel_llist_push_head</a>(&amp;list, &amp;nodes[1]);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="iterator_8h.html#a0646f93de558b7d6c5c312c010cf7254">uel_iterator_llist_t</a> llist_iterator = <a class="code" href="iterator_8h.html#ae6d556c0d69311f1ea8deb05ddb722a4">uel_iterator_llist_create</a>(&amp;list);</div>
</div><!-- fragment --><h3>Iterator operation</h3>
<p>Iterators live entirely on an embedded function pointer, <code>next</code>. It is responsible by yielding a pointer to each element in the collection.</p>
<p>```c // cast to generic iterator uel_iterator_t *iterator = (uel_iterator_t *)</p>
<p>// when supplied with <code>NULL</code> as parameter to <code>next</code>, yields // the first element in the collection int *current = NULL;</p>
<p>while(true){ current = (int *)iterator-&gt;next(iterator, (void *)current); if(current != NULL){ // do something }else break; // when there are no more elements , yields <code>NULL</code> } ```</p>
<h3>Iteration helpers</h3>
<p>Besides manually operating an iterator, there are several iteration helpers that automatise work.</p>
<p>```c #include &lt;<a class="el" href="closure_8h.html" title="Defines closures, objects that bind functions to creating and calling contexts.">uevloop/utils/closure.h</a>&gt;</p>
<p>void *accumulate(void *context, void *params){ uintptr_t *acc = (uintptr_t *)context; uintptr_t num = *(uintptr_t *)params; *acc += num; return (void *)true; // required; returning false is equivalent to a <code>break</code> }</p>
<p>uintptr_t acc = 0; uel_closure_t acumulate_into_acc = uel_closure_create(accumulate, (void *)&amp;acc);</p>
<p>uel_iterator_foreach(iterator, &amp;accumulate_into_acc); // if <code>iterator</code> is the same array iterator defined previously, // acc == 15 </p><div class="fragment"><div class="line">There are many more iteration helpers, check the more details on [the docs](https://andsmedeiros.github.io/uevloop/html/iterator_8h.html).</div>
<div class="line"> </div>
<div class="line">#### Custom iterators</div>
<div class="line"> </div>
<div class="line">Iterators are meant to be expansible. If you need to enumerate your own type, write an iterator specialisation:</div>
<div class="line"> </div>
<div class="line">```c</div>
<div class="line">struct my_collection_type{</div>
<div class="line">    // whatever, could be a binary tree, a hash table etc</div>
<div class="line">};</div>
<div class="line">struct my_collection_iterator{</div>
<div class="line">    uel_iterator_t base; // inherits the base interface</div>
<div class="line">    // any other state necessary for iteration</div>
<div class="line">};</div>
<div class="line">void *my_collection_next(my_collection_iterator *iterator, void *last){</div>
<div class="line">    // implement your iteration logic here.</div>
<div class="line">    // remember:</div>
<div class="line">    //   if last == NULL, yield the first element.</div>
<div class="line">    //   if last == last element in collection, yield NULL.</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct my_collection_type collection; // initialised as needed</div>
<div class="line">struct my_collection_iterator iterator = {</div>
<div class="line">    { (uel_iterator_next_t)&amp;my_collection_next, (void *)&amp;collection },</div>
<div class="line">    // initialise any state as necessary</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that <code>base</code> is <b>required</b> to be the first member in your custom iterator structure. That way, a pointer to your iterator can be safely cast to <code>uel_iterator_t *</code> forth and back.</p>
<h2>Conditionals</h2>
<p>Conditionals are functional switches in the form of a tuple of closures <code>&lt;test, if_true, if_false&gt;</code>.</p>
<p>When applied to some input, this input is submitted to the <code>test</code> closure. If it returns <code>true</code>, <code>if_true</code> closure is invoked, otherwise, <code>if_false</code> is invoked. All closures take the same input as arguments.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional_8h.html">uevloop/utils/conditional.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *is_divisible(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uintptr_t divisor = (uintptr_t)context;</div>
<div class="line">    uintptr_t dividend = (uintptr_t)params;</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(uintptr_t)(dividend % divisor != 0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *qualify_number(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    <span class="keywordtype">char</span> *parity = (<span class="keywordtype">char</span> *)context;</div>
<div class="line">    uintptr_t num = (uintptr_t)params;</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d is %s\n&quot;</span>, num, parity);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uel_closure_t is_even =</div>
<div class="line">        <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(is_divisible, (<span class="keywordtype">void</span> *)2);</div>
<div class="line">uel_closure_t print_even =</div>
<div class="line">        <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(qualify_number, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;even&quot;</span>);</div>
<div class="line">uel_closure_t print_odd =</div>
<div class="line">        <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(qualify_number, (<span class="keywordtype">void</span> *)<span class="stringliteral">&quot;odd&quot;</span>);</div>
<div class="line"> </div>
<div class="line">uel_conditional_t numer_parity;</div>
<div class="line"><a class="code" href="conditional_8h.html#acb6e7aa5cd25863e7a628d233a967412">uel_conditional_init</a>(&amp;number_parity, is_even, print_even, print_odd);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="conditional_8h.html#a09ded07bf4d8645615a25557a87c996d">uel_conditional_apply</a>(&amp;number_parity, (<span class="keywordtype">void</span> *)1);</div>
<div class="line"><span class="comment">// prints &quot;1 is odd&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="conditional_8h.html#a09ded07bf4d8645615a25557a87c996d">uel_conditional_apply</a>(&amp;number_parity, (<span class="keywordtype">void</span> *)2);</div>
<div class="line"><span class="comment">// prints &quot;2 is even&quot;</span></div>
</div><!-- fragment --><h2>Pipelines</h2>
<p>Pipelines are sequences of closures whose outputs are connected to the next closure's input.</p>
<p>When applied to some input, this input is passed along each closure, being transformed along the way. Applying a pipeline returns the value returned by the last closure in it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pipeline_8h.html">uevloop/utils/pipeline.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *exponentiate(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uintptr_t power = (uintptr_t)context;</div>
<div class="line">    uintptr_t base = (uintptr_t)params;</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(uintptr_t)pow(base, power);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> *add(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params){</div>
<div class="line">    uintptr_t term1 = (uintptr_t)context;</div>
<div class="line">    uintptr_t term2 = (uintptr_t)params;</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(uintptr_t)(term1 + term2);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uel_closure_t square = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(exponentiate, (<span class="keywordtype">void</span> *)2);</div>
<div class="line">uel_closure_t increment = <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(add, (<span class="keywordtype">void</span> *)1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creates the math_pipeline, equivalent to the function f(x) = x^2 + 1</span></div>
<div class="line"><a class="code" href="pipeline_8h.html#a64c47a347b70a55627e1a66a9972890c">UEL_PIPELINE_DECLARE</a>(math, square, increment);</div>
<div class="line"> </div>
<div class="line">uintptr_t res = (uintptr_t)<a class="code" href="pipeline_8h.html#a54df79756518430d753961735c93d270">uel_pipeline_apply</a>(&amp;math_pipeline, (<span class="keywordtype">void</span> *)5);</div>
<div class="line"><span class="comment">// res == f(5) == (5^2 + 1) == 26</span></div>
</div><!-- fragment --><h2>Functional helpers</h2>
<p>Iterators, conditionals and pipelines are objects associated with synchronous operations.</p>
<p>To make more suitable to asynchronous contexts, there are numerous helpers that can abstract some of their operational details and export them into portable closures.</p>
<p>Please read <a href="https://andsmedeiros.github.io/uevloop/html/functional_8h.html">the docs</a> to find out more about them.</p>
<h2>Automatic pools and automatic pointers</h2>
<p>Automatic pools are wrappers objects that enhance the abilities of object pools. They allow constructors and destructors to be attached and, instead of yielding bare pointers, yield <code>uel_autoptr_t</code> automatic pointers.</p>
<p>Automatic pointers are objects that associate some object to the pool it is from, making it trivial to destroy the object regardless of access to its source. An automatic pointer issued to an object of type <code>T</code> can be safely cast to <code>T**</code>. Casting to any other pointer type is undefined behaviour.</p>
<h3>Automatic pool creation</h3>
<p>Automatic pools are created and initialised in very similar ways to object pools:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="automatic-pool_8h.html">uevloop/utils/automatic-pool.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TUPLE_POOL_SIZE_LOG2N    5    // 32 tuples</span></div>
<div class="line"><span class="keyword">struct </span>tuple {</div>
<div class="line">    <span class="keywordtype">int</span> a;</div>
<div class="line">    <span class="keywordtype">int</span> b;</div>
<div class="line">};</div>
<div class="line"><a class="code" href="automatic-pool_8h.html#a59c59798394f60a6e567954997cc8176">UEL_DECLARE_AUTOPOOL_BUFFERS</a>(<span class="keyword">struct</span> tuple, TUPLE_POOL_SIZE_LOG2N, tuple);</div>
<div class="line">uel_autopool_t tuple_pool;</div>
<div class="line"><a class="code" href="automatic-pool_8h.html#a32b26c65f4e2c7dfc733e14a0c06b746">uel_autopool_init</a>(</div>
<div class="line">    &amp;tuple_pool,</div>
<div class="line">    TUPLE_POOL_SIZE_LOG2N,</div>
<div class="line">    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tuple),</div>
<div class="line">    <a class="code" href="automatic-pool_8h.html#a956766ef0a875886ce9cee1751fed842">UEL_AUTOPOOL_BUFFERS</a>(tuple)</div>
<div class="line">);</div>
</div><!-- fragment --><h3>Automatic pool operation and automatic pointer destruction</h3>
<p>After an automatic pool has been created, it can allocate and deallocate objects, just like object pools.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>tuple **t = (<span class="keyword">struct </span>tuple **)<a class="code" href="automatic-pool_8h.html#aa4824c8fb0acb2059ee3c1ebf327712f">uel_autopool_alloc</a>(&amp;tuple_pool);</div>
<div class="line"><span class="keywordflow">if</span>(t) {</div>
<div class="line">    (**t).a = 1;</div>
<div class="line">    (**t).b = 10;</div>
<div class="line">    <a class="code" href="automatic-pool_8h.html#affb23d5f2209456cfcb4228ae258f409">uel_autoptr_dealloc</a>((<a class="code" href="automatic-pool_8h.html#a83a2aef2df919bea22dd489c0a5403fd">uel_autoptr_t</a>)t);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Automatic pool constructors and destructors</h3>
<p>It is possible to attach a constructor and a destructor to some automatic pool. This are closures that will be invoked upon object allocation and deallocation, taking a <b>bare</b> pointer to the object being operated on.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *default_tuple(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keyword">struct </span>tuple *value = (<span class="keyword">struct </span>tuple *)context;</div>
<div class="line">    <span class="keyword">struct </span>tuple *t = (<span class="keyword">struct </span>tuple *)params;</div>
<div class="line">    *t = *value;</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *zero_tuple(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *params) {</div>
<div class="line">    <span class="keyword">struct </span>tuple *t = (<span class="keyword">struct </span>tuple *)params;</div>
<div class="line">    t-&gt;a = 0;</div>
<div class="line">    t-&gt;b = 0;</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>tuple default_value = { 10, 100 };</div>
<div class="line">uel_autopool_set_contructor(</div>
<div class="line">    &amp;tuple_pool,</div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(default_tuple, (<span class="keywordtype">void</span> *)&amp;default_value)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="automatic-pool_8h.html#a7f57eb19fffa1865c2a8b69aa61acc2b">uel_autopool_set_destructor</a>(</div>
<div class="line">    &amp;tuple_pool,</div>
<div class="line">    <a class="code" href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a>(zero_tuple, NULL)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>tuple **t1 = (<span class="keyword">struct </span>tuple **)<a class="code" href="automatic-pool_8h.html#aa4824c8fb0acb2059ee3c1ebf327712f">uel_autopool_alloc</a>(&amp;tuple_pool);</div>
<div class="line"><span class="comment">// t1.a == 10, t1.b == 100</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="automatic-pool_8h.html#affb23d5f2209456cfcb4228ae258f409">uel_autoptr_dealloc</a>((<a class="code" href="automatic-pool_8h.html#a83a2aef2df919bea22dd489c0a5403fd">uel_autoptr_t</a>)t1);</div>
<div class="line"><span class="comment">// before t1 is dealloc&#39;ed t1.a == 0, t1.b == 0</span></div>
</div><!-- fragment --><h1>Concurrency model</h1>
<p>µEvLoop is meant to run baremetal, primarily in simple single-core MCUs. That said, nothing stops it from being employed as a side library in RTOSes or in full-fledged x86_64 multi-threaded desktop applications.</p>
<p>Communication between asynchronous contexts, such as ISRs and side threads, is done through some shared data structures defined inside the library's core components. As whenever dealing with non-atomic shared memory, there must be synchronisation between accesses to these structures as to avoid memory corruption.</p>
<p>µEvLoop does not try to implement a universal locking scheme fit for any device. Instead, some generic critical section definition is provided.</p>
<h2>Critical sections</h2>
<p>By default, critical sections in µEvLoop are a no-op. They are provided as a set of macros that can be overriden by the programmer to implement platform specific behaviour.</p>
<p>For instance, while running baremetal it may be only necessary to disable interrupts to make sure accesses are synchronised. On a RTOS multi-threaded environment, on the other hand, it may be necessary to use a mutex.</p>
<p>There are three macros that define critical section implementation:</p>
<ol type="1">
<li><p class="startli"><code>UEL_CRITICAL_SECTION_OBJ_TYPE</code></p>
<p class="startli">If needed, a global critical section object can be declared. If this macro is defined, this object will be available to any critical section under the symbol <code>uel_critical_section</code>.</p>
<p class="startli">The <code>UEL_CRITICAL_SECTION_OBJ_TYPE</code> macro defines the <b>type</b> of the object. It is the programmer's responsibility to declare, globally allocate and initialise the object.</p>
</li>
<li><p class="startli"><code>UEL_CRITICAL_ENTER</code></p>
<p class="startli">Enters a new critical section. From this point until the critical section exits, no other thread or ISR may attempt to access the system's shared memory.</p>
</li>
<li><p class="startli"><code>UEL_CRITICAL_EXIT</code></p>
<p class="startli">Exits the current critical section. After this is called, any shared memory is allowed to be claimed by some party.</p>
</li>
</ol>
<h1>Motivation</h1>
<p>I often work with small MCUs (8-16bits) that simply don't have the necessary power to run a RTOS or any fancy scheduling solution. Right now I am working on a new commercial project and felt the need to build something by my own. µEvLoop is my bet on how a modern, interrupt-driven and predictable embedded application should be. I am also looking for a new job and needed to improve my portfolio.</p>
<h1>Roadmap</h1>
<ul>
<li>Better error handling</li>
<li>Logging helpers</li>
<li>Macro shortcuts for frequently used functions</li>
<li>More lifecycle hooks for modules</li>
<li>Application teardown/exit</li>
<li>Implement <a href="#application">application</a> signals </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="asignal_8h_html_af849f4effe2577efe439387d3a8a710a"><div class="ttname"><a href="signal_8h.html#af849f4effe2577efe439387d3a8a710a">uel_signal_emit</a></div><div class="ttdeci">void uel_signal_emit(uel_signal_t signal, uel_signal_relay_t *relay, void *params)</div><div class="ttdoc">Emits a signal at the supplied relay. Any closure listening to this signal will be asynchronously inv...</div></div>
<div class="ttc" id="aiterator_8h_html_a0acc2751d0a555963f923fca73c0200a"><div class="ttname"><a href="iterator_8h.html#a0acc2751d0a555963f923fca73c0200a">uel_iterator_array_create</a></div><div class="ttdeci">uel_iterator_array_t uel_iterator_array_create(void *collection, size_t count, size_t size)</div><div class="ttdoc">Creates a new array iterator.</div></div>
<div class="ttc" id="apipeline_8h_html"><div class="ttname"><a href="pipeline_8h.html">pipeline.h</a></div><div class="ttdoc">Defines pipelines, structures to hold many closures and functions to invoke them sequentially,...</div></div>
<div class="ttc" id="alinked-list_8h_html"><div class="ttname"><a href="linked-list_8h.html">linked-list.h</a></div><div class="ttdoc">Defines a simple implementation of linked lists and functions to manipulate it.</div></div>
<div class="ttc" id="acircular-queue_8h_html_a818331aa6bf56e977f7a95d996e9009d"><div class="ttname"><a href="circular-queue_8h.html#a818331aa6bf56e977f7a95d996e9009d">uel_cqueue_pop</a></div><div class="ttdeci">void * uel_cqueue_pop(uel_cqueue_t *queue)</div><div class="ttdoc">Pops an element from the queue.</div></div>
<div class="ttc" id="aevent-loop_8h_html_ad5371df9faa7072e1fd11470448de901"><div class="ttname"><a href="event-loop_8h.html#ad5371df9faa7072e1fd11470448de901">uel_evloop_run</a></div><div class="ttdeci">void uel_evloop_run(uel_evloop_t *event_loop)</div><div class="ttdoc">Triggers a runloop.</div></div>
<div class="ttc" id="apromise_8h_html_a2d226c4ed1a94964db50dbb5a7f958df"><div class="ttname"><a href="promise_8h.html#a2d226c4ed1a94964db50dbb5a7f958df">uel_promise_resettle</a></div><div class="ttdeci">void uel_promise_resettle(uel_promise_t *promise, uel_promise_state_t state, void *value)</div><div class="ttdoc">Resettles a promise as the supplied state. Unlike uel_promise_resolve() and uel_promise_reject(),...</div></div>
<div class="ttc" id="apromise_8h_html_a5c0cdf2e971bf738362af1761c729bd4"><div class="ttname"><a href="promise_8h.html#a5c0cdf2e971bf738362af1761c729bd4">uel_promise_create</a></div><div class="ttdeci">uel_promise_t * uel_promise_create(uel_promise_store_t *store, uel_closure_t closure)</div><div class="ttdoc">Acquires a new promise from the supplied store and binds it to the asynchronous operation started by ...</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_aa4824c8fb0acb2059ee3c1ebf327712f"><div class="ttname"><a href="automatic-pool_8h.html#aa4824c8fb0acb2059ee3c1ebf327712f">uel_autopool_alloc</a></div><div class="ttdeci">uel_autoptr_t uel_autopool_alloc(uel_autopool_t *pool)</div><div class="ttdoc">Allocates an object and wrap it in a automatic pointer.</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_a59c59798394f60a6e567954997cc8176"><div class="ttname"><a href="automatic-pool_8h.html#a59c59798394f60a6e567954997cc8176">UEL_DECLARE_AUTOPOOL_BUFFERS</a></div><div class="ttdeci">#define UEL_DECLARE_AUTOPOOL_BUFFERS(type, size_log2n, id)</div><div class="ttdoc">Declares the necessary buffers to back an automatic pool, so the programmer doesn't have to reason mu...</div><div class="ttdef"><b>Definition:</b> automatic-pool.h:134</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_a83a2aef2df919bea22dd489c0a5403fd"><div class="ttname"><a href="automatic-pool_8h.html#a83a2aef2df919bea22dd489c0a5403fd">uel_autoptr_t</a></div><div class="ttdeci">void ** uel_autoptr_t</div><div class="ttdoc">Aliases uel_autoptr_t to void ** so it can be cast to pointers to other types.</div><div class="ttdef"><b>Definition:</b> automatic-pool.h:34</div></div>
<div class="ttc" id="asystem-pools_8h_html_a737df9d7ca7c587711dc8c59d9f1c277"><div class="ttname"><a href="system-pools_8h.html#a737df9d7ca7c587711dc8c59d9f1c277">uel_syspools_init</a></div><div class="ttdeci">void uel_syspools_init(uel_syspools_t *pools)</div><div class="ttdoc">Initialise the system pools.</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_a32b26c65f4e2c7dfc733e14a0c06b746"><div class="ttname"><a href="automatic-pool_8h.html#a32b26c65f4e2c7dfc733e14a0c06b746">uel_autopool_init</a></div><div class="ttdeci">void uel_autopool_init(uel_autopool_t *pool, size_t size_log2n, size_t item_size, uint8_t *object_buffer, struct uel_autoptr *autoptr_buffer, void **queue_buffer)</div><div class="ttdoc">Initialises an automatic pool.</div></div>
<div class="ttc" id="asystem-queues_8h_html_aa988e6daddfd00129d56c1db350edc5a"><div class="ttname"><a href="system-queues_8h.html#aa988e6daddfd00129d56c1db350edc5a">uel_sysqueues_init</a></div><div class="ttdeci">void uel_sysqueues_init(uel_sysqueues_t *queues)</div><div class="ttdoc">Initialises a new uel_sysqueues_t.</div></div>
<div class="ttc" id="aclosure_8h_html"><div class="ttname"><a href="closure_8h.html">closure.h</a></div><div class="ttdoc">Defines closures, objects that bind functions to creating and calling contexts.</div></div>
<div class="ttc" id="aobject-pool_8h_html_a54248e0810ccb791a8ff82d3de8fc6c5"><div class="ttname"><a href="object-pool_8h.html#a54248e0810ccb791a8ff82d3de8fc6c5">uel_objpool_acquire</a></div><div class="ttdeci">void * uel_objpool_acquire(uel_objpool_t *pool)</div><div class="ttdoc">Acquires an object from the pool.</div></div>
<div class="ttc" id="amodule_8h_html"><div class="ttname"><a href="module_8h.html">module.h</a></div></div>
<div class="ttc" id="apromise_8h_html_a4b1b8ee1101104f1beaa782ef630767f"><div class="ttname"><a href="promise_8h.html#a4b1b8ee1101104f1beaa782ef630767f">uel_promise_after</a></div><div class="ttdeci">void uel_promise_after(uel_promise_t *promise, uel_closure_t resolve, uel_closure_t reject)</div><div class="ttdoc">Adds a new synchronous segment to the promise. Either of its closures will be invoked,...</div></div>
<div class="ttc" id="aautomatic-pool_8h_html"><div class="ttname"><a href="automatic-pool_8h.html">automatic-pool.h</a></div><div class="ttdoc">Defines automatic pointers and automatic pools, objects that wrap object pools and objects managed by...</div></div>
<div class="ttc" id="apromise_8h_html_a9b68547bf7ac1a5860b165a4638bcc51"><div class="ttname"><a href="promise_8h.html#a9b68547bf7ac1a5860b165a4638bcc51">uel_promise_destroyer</a></div><div class="ttdeci">uel_closure_t uel_promise_destroyer(uel_promise_t *promise)</div><div class="ttdoc">Creates a closure bound to a promise. When the closure is invoked, the promise is destroyed....</div></div>
<div class="ttc" id="aclosure_8h_html_a1f88fc773dbcea710594c7175d3a4ac3"><div class="ttname"><a href="closure_8h.html#a1f88fc773dbcea710594c7175d3a4ac3">uel_nop</a></div><div class="ttdeci">uel_closure_t uel_nop()</div><div class="ttdoc">Returns a closure that does nothing.</div></div>
<div class="ttc" id="aconditional_8h_html_a09ded07bf4d8645615a25557a87c996d"><div class="ttname"><a href="conditional_8h.html#a09ded07bf4d8645615a25557a87c996d">uel_conditional_apply</a></div><div class="ttdeci">void * uel_conditional_apply(uel_conditional_t *conditional, void *params)</div><div class="ttdoc">Applies a conditional do some input.</div></div>
<div class="ttc" id="aobject-pool_8h_html_a6f94946d39d323f7ea0f409962c59f1e"><div class="ttname"><a href="object-pool_8h.html#a6f94946d39d323f7ea0f409962c59f1e">UEL_DECLARE_OBJPOOL_BUFFERS</a></div><div class="ttdeci">#define UEL_DECLARE_OBJPOOL_BUFFERS(type, size_log2n, id)</div><div class="ttdoc">Declares the necessary buffers to back an object pool, so the programmer doesn't have to reason much ...</div><div class="ttdef"><b>Definition:</b> object-pool.h:85</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_a956766ef0a875886ce9cee1751fed842"><div class="ttname"><a href="automatic-pool_8h.html#a956766ef0a875886ce9cee1751fed842">UEL_AUTOPOOL_BUFFERS</a></div><div class="ttdeci">#define UEL_AUTOPOOL_BUFFERS(id)</div><div class="ttdoc">Refers to a previously declared buffer set.</div><div class="ttdef"><b>Definition:</b> automatic-pool.h:146</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_affb23d5f2209456cfcb4228ae258f409"><div class="ttname"><a href="automatic-pool_8h.html#affb23d5f2209456cfcb4228ae258f409">uel_autoptr_dealloc</a></div><div class="ttdeci">void uel_autoptr_dealloc(uel_autoptr_t autoptr)</div><div class="ttdoc">Deallocates an automatic pointer.</div></div>
<div class="ttc" id="apromise_8h_html_abb34042cccffccafefb813a902ec8389"><div class="ttname"><a href="promise_8h.html#abb34042cccffccafefb813a902ec8389">uel_promise_then</a></div><div class="ttdeci">void uel_promise_then(uel_promise_t *promise, uel_closure_t resolve)</div><div class="ttdoc">Adds a new synchronous segment to the promise. It will be invoked upon promise resolution....</div></div>
<div class="ttc" id="aclosure_8h_html_adbc9cc1a9562693b06bfacd82d8ac978"><div class="ttname"><a href="closure_8h.html#adbc9cc1a9562693b06bfacd82d8ac978">uel_closure_create</a></div><div class="ttdeci">uel_closure_t uel_closure_create(uel_closure_function_t function, void *context)</div><div class="ttdoc">Creates a new closure.</div></div>
<div class="ttc" id="apromise_8h_html_ac0201d84b1e362087d83bdb57a8e8856ae137a12a3c564815d59e2548e304ab39"><div class="ttname"><a href="promise_8h.html#ac0201d84b1e362087d83bdb57a8e8856ae137a12a3c564815d59e2548e304ab39">UEL_PROMISE_REJECTED</a></div><div class="ttdeci">@ UEL_PROMISE_REJECTED</div><div class="ttdoc">A promise that has been rejected with some error.</div><div class="ttdef"><b>Definition:</b> promise.h:22</div></div>
<div class="ttc" id="aobject-pool_8h_html"><div class="ttname"><a href="object-pool_8h.html">object-pool.h</a></div><div class="ttdoc">Defines object pools, arrays of pre-allocated objects for dynamic use.</div></div>
<div class="ttc" id="acircular-queue_8h_html_acf451cae31642c456faada2501a4977e"><div class="ttname"><a href="circular-queue_8h.html#acf451cae31642c456faada2501a4977e">uel_cqueue_init</a></div><div class="ttdeci">void uel_cqueue_init(uel_cqueue_t *queue, void **buffer, uintptr_t size_log2n)</div><div class="ttdoc">Initialised a circular queue object.</div></div>
<div class="ttc" id="apromise_8h_html_a6a932817fcd43d5eaa2723b8c34132ff"><div class="ttname"><a href="promise_8h.html#a6a932817fcd43d5eaa2723b8c34132ff">uel_promise_always</a></div><div class="ttdeci">void uel_promise_always(uel_promise_t *promise, uel_closure_t always)</div><div class="ttdoc">Adds a new synchronous segment to the promise. The same closure will be invoked on promise settling r...</div></div>
<div class="ttc" id="aevent-loop_8h_html_a1d3464894f0281c7b1f4c9c18dddcaf4"><div class="ttname"><a href="event-loop_8h.html#a1d3464894f0281c7b1f4c9c18dddcaf4">uel_evloop_enqueue_closure</a></div><div class="ttdeci">void uel_evloop_enqueue_closure(uel_evloop_t *event_loop, uel_closure_t *closure, void *value)</div><div class="ttdoc">Enqueues a closure to be invoked.</div></div>
<div class="ttc" id="aobject-pool_8h_html_af4370a164b82e436749fbc9f8af9a114"><div class="ttname"><a href="object-pool_8h.html#af4370a164b82e436749fbc9f8af9a114">uel_objpool_release</a></div><div class="ttdeci">bool uel_objpool_release(uel_objpool_t *pool, void *element)</div><div class="ttdoc">Releases an object to the pool.</div></div>
<div class="ttc" id="alinked-list_8h_html_a636d9d433df7fd53fc3138b6c77df75a"><div class="ttname"><a href="linked-list_8h.html#a636d9d433df7fd53fc3138b6c77df75a">uel_llist_init</a></div><div class="ttdeci">void uel_llist_init(uel_llist_t *list)</div><div class="ttdoc">Initialised a linked list.</div></div>
<div class="ttc" id="aclosure_8h_html_adcd44820dd3715e206fdf71800e8926c"><div class="ttname"><a href="closure_8h.html#adcd44820dd3715e206fdf71800e8926c">uel_closure_invoke</a></div><div class="ttdeci">void * uel_closure_invoke(uel_closure_t *closure, void *params)</div><div class="ttdoc">Invokes a closure and returns whatever value it returned.</div></div>
<div class="ttc" id="apromise_8h_html_a4e3a7f9f0d154d4a2fa1c17520bd5561"><div class="ttname"><a href="promise_8h.html#a4e3a7f9f0d154d4a2fa1c17520bd5561">uel_promise_store_create</a></div><div class="ttdeci">uel_promise_store_t uel_promise_store_create(uel_objpool_t *promise_pool, uel_objpool_t *segment_pool)</div><div class="ttdoc">Creates a new promise store from the promise and segment pools.</div></div>
<div class="ttc" id="aiterator_8h_html"><div class="ttname"><a href="iterator_8h.html">iterator.h</a></div><div class="ttdoc">Defines iterators, structures and functions suitable for enumerating other data structures.</div></div>
<div class="ttc" id="acircular-queue_8h_html"><div class="ttname"><a href="circular-queue_8h.html">circular-queue.h</a></div><div class="ttdoc">Defines circular queues, fast and efficient FIFO data structures.</div></div>
<div class="ttc" id="aiterator_8h_html_ae6d556c0d69311f1ea8deb05ddb722a4"><div class="ttname"><a href="iterator_8h.html#ae6d556c0d69311f1ea8deb05ddb722a4">uel_iterator_llist_create</a></div><div class="ttdeci">uel_iterator_llist_t uel_iterator_llist_create(uel_llist_t *list)</div><div class="ttdoc">Creates a new linked list iterator.</div></div>
<div class="ttc" id="asignal_8h_html_a6d59d4a7b4c0c5f6b1d271ed6e8a8212"><div class="ttname"><a href="signal_8h.html#a6d59d4a7b4c0c5f6b1d271ed6e8a8212">uel_signal_listen_once</a></div><div class="ttdeci">uel_signal_listener_t uel_signal_listen_once(uel_signal_t signal, uel_signal_relay_t *relay, uel_closure_t *closure)</div><div class="ttdoc">Attaches a listener closure to some signal at a particular relay. The listener closure will be invoke...</div></div>
<div class="ttc" id="apipeline_8h_html_a64c47a347b70a55627e1a66a9972890c"><div class="ttname"><a href="pipeline_8h.html#a64c47a347b70a55627e1a66a9972890c">UEL_PIPELINE_DECLARE</a></div><div class="ttdeci">#define UEL_PIPELINE_DECLARE(id,...)</div><div class="ttdoc">Helper macro to create a pipeline and its required data structures.</div><div class="ttdef"><b>Definition:</b> pipeline.h:59</div></div>
<div class="ttc" id="apromise_8h_html_a2e904cfb182cb5619b0a31790fca697e"><div class="ttname"><a href="promise_8h.html#a2e904cfb182cb5619b0a31790fca697e">uel_promise_reject</a></div><div class="ttdeci">void uel_promise_reject(uel_promise_t *promise, void *value)</div><div class="ttdoc">Settles a promise as rejected and, synchronously, invokes the reject closures of each segment in the ...</div></div>
<div class="ttc" id="aiterator_8h_html_a0646f93de558b7d6c5c312c010cf7254"><div class="ttname"><a href="iterator_8h.html#a0646f93de558b7d6c5c312c010cf7254">uel_iterator_llist_t</a></div><div class="ttdeci">uel_iterator_t uel_iterator_llist_t</div><div class="ttdoc">Alias to uel_iterator_t. Iterator suitable to traverse linked lists.</div><div class="ttdef"><b>Definition:</b> iterator.h:158</div></div>
<div class="ttc" id="ascheduler_8h_html_ad5909fddc1856cc1b980a0445602c67c"><div class="ttname"><a href="scheduler_8h.html#ad5909fddc1856cc1b980a0445602c67c">uel_sch_run_later</a></div><div class="ttdeci">uel_event_t * uel_sch_run_later(uel_scheduer_t *scheduler, uint16_t timeout_in_ms, uel_closure_t closure, void *value)</div><div class="ttdoc">Enqueues a closure for later execution.</div></div>
<div class="ttc" id="aapplication_8h_html_ab221d8fc71af4fbf92525a7691b039ae"><div class="ttname"><a href="application_8h.html#ab221d8fc71af4fbf92525a7691b039ae">uel_app_init</a></div><div class="ttdeci">void uel_app_init(uel_application_t *app)</div><div class="ttdoc">Initialises an uel_application_t instance.</div></div>
<div class="ttc" id="amodule_8h_html_a3a1d7dc04cf2b7c5c84a61cfd5056772"><div class="ttname"><a href="module_8h.html#a3a1d7dc04cf2b7c5c84a61cfd5056772">uel_module_init</a></div><div class="ttdeci">void uel_module_init(uel_module_t *module, uel_module_hook_t config, uel_module_hook_t launch, struct uel_application *app)</div><div class="ttdoc">Initialised a module.</div></div>
<div class="ttc" id="apipeline_8h_html_a54df79756518430d753961735c93d270"><div class="ttname"><a href="pipeline_8h.html#a54df79756518430d753961735c93d270">uel_pipeline_apply</a></div><div class="ttdeci">void * uel_pipeline_apply(uel_pipeline_t *pipeline, void *params)</div><div class="ttdoc">Applies a pipeline to some input.</div></div>
<div class="ttc" id="apromise_8h_html_a09b820cf5093f6979da34cbe6faa1787"><div class="ttname"><a href="promise_8h.html#a09b820cf5093f6979da34cbe6faa1787">uel_promise_rejecter</a></div><div class="ttdeci">uel_closure_t uel_promise_rejecter(uel_promise_t *promise)</div><div class="ttdoc">Creates a closure bound to a promise. When the closure is invoked with some parameter,...</div></div>
<div class="ttc" id="apromise_8h_html_acffa84389150a36442905a6f89cb827b"><div class="ttname"><a href="promise_8h.html#acffa84389150a36442905a6f89cb827b">uel_promise_resolver</a></div><div class="ttdeci">uel_closure_t uel_promise_resolver(uel_promise_t *promise)</div><div class="ttdoc">Creates a closure bound to a promise. When the closure is invoked with some parameter,...</div></div>
<div class="ttc" id="ascheduler_8h_html_a6a993056042a7649e1e7375eb2bb588d"><div class="ttname"><a href="scheduler_8h.html#a6a993056042a7649e1e7375eb2bb588d">uel_sch_run_at_intervals</a></div><div class="ttdeci">uel_event_t * uel_sch_run_at_intervals(uel_scheduer_t *scheduler, uint16_t interval_in_ms, bool immediate, uel_closure_t closure, void *value)</div><div class="ttdoc">Enqueues a closure for execution at intervals.</div></div>
<div class="ttc" id="apromise_8h_html_a550561c65f5abb38bc5c3b25083dd468"><div class="ttname"><a href="promise_8h.html#a550561c65f5abb38bc5c3b25083dd468">uel_promise_catch</a></div><div class="ttdeci">void uel_promise_catch(uel_promise_t *promise, uel_closure_t reject)</div><div class="ttdoc">Adds a new synchronous segment to the promise. It will be invoked upon promise rejection....</div></div>
<div class="ttc" id="asignal_8h_html_ac11a6acd9237d30551bc0dc8ba406189"><div class="ttname"><a href="signal_8h.html#ac11a6acd9237d30551bc0dc8ba406189">uel_signal_listen</a></div><div class="ttdeci">uel_signal_listener_t uel_signal_listen(uel_signal_t signal, uel_signal_relay_t *relay, uel_closure_t *closure)</div><div class="ttdoc">Attaches a listener closure to some signal at a particular relay.</div></div>
<div class="ttc" id="aautomatic-pool_8h_html_a7f57eb19fffa1865c2a8b69aa61acc2b"><div class="ttname"><a href="automatic-pool_8h.html#a7f57eb19fffa1865c2a8b69aa61acc2b">uel_autopool_set_destructor</a></div><div class="ttdeci">void uel_autopool_set_destructor(uel_autopool_t *pool, uel_closure_t destructor)</div><div class="ttdoc">Sets the destructor closure of an autopool.</div></div>
<div class="ttc" id="ascheduler_8h_html_a0a5a89adf45a470aed0e39925a256ea2"><div class="ttname"><a href="scheduler_8h.html#a0a5a89adf45a470aed0e39925a256ea2">uel_sch_update_timer</a></div><div class="ttdeci">void uel_sch_update_timer(uel_scheduer_t *scheduler, uint32_t timer)</div><div class="ttdoc">Updates the internal time counter.</div></div>
<div class="ttc" id="aobject-pool_8h_html_a623ea70a0df4cc76d0e65a99bc5c26c9"><div class="ttname"><a href="object-pool_8h.html#a623ea70a0df4cc76d0e65a99bc5c26c9">UEL_OBJPOOL_BUFFERS</a></div><div class="ttdeci">#define UEL_OBJPOOL_BUFFERS(id)</div><div class="ttdoc">Refers to a previously declared buffer set.</div><div class="ttdef"><b>Definition:</b> object-pool.h:96</div></div>
<div class="ttc" id="alinked-list_8h_html_a0a98f53f55f86adb45e4f0f357d748a8"><div class="ttname"><a href="linked-list_8h.html#a0a98f53f55f86adb45e4f0f357d748a8">uel_llist_push_head</a></div><div class="ttdeci">void uel_llist_push_head(uel_llist_t *list, uel_llist_node_t *node)</div><div class="ttdoc">Pushes a node to the head of the list.</div></div>
<div class="ttc" id="asystem-queues_8h_html"><div class="ttname"><a href="system-queues_8h.html">system-queues.h</a></div><div class="ttdoc">A container for the system's internal queues.</div></div>
<div class="ttc" id="aapplication_8h_html_aed8a446de669fcab5bc591fb28d3b5f6"><div class="ttname"><a href="application_8h.html#aed8a446de669fcab5bc591fb28d3b5f6">uel_app_load</a></div><div class="ttdeci">void uel_app_load(uel_application_t *app, uel_module_t **modules, size_t module_count)</div><div class="ttdoc">Loads modules into an application and run their lifecycle hooks.</div></div>
<div class="ttc" id="aconditional_8h_html"><div class="ttname"><a href="conditional_8h.html">conditional.h</a></div><div class="ttdoc">Contains definitions of functional conditionals, structures that act as if-else constructs.</div></div>
<div class="ttc" id="acircular-queue_8h_html_ae65acd13845cdd8e2492201538c2e968"><div class="ttname"><a href="circular-queue_8h.html#ae65acd13845cdd8e2492201538c2e968">uel_cqueue_push</a></div><div class="ttdeci">bool uel_cqueue_push(uel_cqueue_t *queue, void *element)</div><div class="ttdoc">Pushes an element into the queue.</div></div>
<div class="ttc" id="asignal_8h_html_a3fb31014f6cec7acf29e7de4b66fe531"><div class="ttname"><a href="signal_8h.html#a3fb31014f6cec7acf29e7de4b66fe531">uel_signal_unlisten</a></div><div class="ttdeci">void uel_signal_unlisten(uel_signal_listener_t listener)</div><div class="ttdoc">Marks a signal listener as expired. When its corresponding signal is emitted, this listener's closure...</div></div>
<div class="ttc" id="asignal_8h_html_acf4ce9806bae5489706f0409f0a58067"><div class="ttname"><a href="signal_8h.html#acf4ce9806bae5489706f0409f0a58067">uel_signal_listener_t</a></div><div class="ttdeci">struct uel_event_listener * uel_signal_listener_t</div><div class="ttdoc">Defines a reference type suitable to manipulate the actual listener event's context.</div><div class="ttdef"><b>Definition:</b> signal.h:27</div></div>
<div class="ttc" id="apromise_8h_html_abe5aae85467a9af06b580df74aeedb8c"><div class="ttname"><a href="promise_8h.html#abe5aae85467a9af06b580df74aeedb8c">uel_promise_resolve</a></div><div class="ttdeci">void uel_promise_resolve(uel_promise_t *promise, void *value)</div><div class="ttdoc">Settles a promise as resolved and, synchronously, invokes the resolve closures of each segment in the...</div></div>
<div class="ttc" id="asystem-pools_8h_html"><div class="ttname"><a href="system-pools_8h.html">system-pools.h</a></div><div class="ttdoc">A container for the system's internal pools.</div></div>
<div class="ttc" id="ascheduler_8h_html_a2666a61c55a518fd602cee03a014ed10"><div class="ttname"><a href="scheduler_8h.html#a2666a61c55a518fd602cee03a014ed10">uel_sch_manage_timers</a></div><div class="ttdeci">void uel_sch_manage_timers(uel_scheduer_t *scheduler)</div><div class="ttdoc">Enqueue timers that are due to be processed in the event queue.</div></div>
<div class="ttc" id="aobject-pool_8h_html_ab49dd047b6e4fcc0939dfd651e3b3666"><div class="ttname"><a href="object-pool_8h.html#ab49dd047b6e4fcc0939dfd651e3b3666">uel_objpool_init</a></div><div class="ttdeci">void uel_objpool_init(uel_objpool_t *pool, size_t size_log2n, size_t item_size, uint8_t *buffer, void **queue_buffer)</div><div class="ttdoc">Initialises an object pool.</div></div>
<div class="ttc" id="aapplication_8h_html"><div class="ttname"><a href="application_8h.html">application.h</a></div><div class="ttdoc">The application module is a convenient top-level container for the system internals.</div></div>
<div class="ttc" id="aconditional_8h_html_acb6e7aa5cd25863e7a628d233a967412"><div class="ttname"><a href="conditional_8h.html#acb6e7aa5cd25863e7a628d233a967412">uel_conditional_init</a></div><div class="ttdeci">void uel_conditional_init(uel_conditional_t *conditional, uel_closure_t test, uel_closure_t if_true, uel_closure_t if_false)</div><div class="ttdoc">Initialises a conditional structure.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
